/**
 * WebDAVè®¾ç½®é¢æ¿
 * é€šè¿‡WebDAVåè®®ï¼Œå°†è§‚çœ‹è®°å½•å¤‡ä»½åˆ°å…¼å®¹çš„äº‘å­˜å‚¨æœåŠ¡
 */

import { STATE } from '../../../state';
import { BaseSettingsPanel } from '../base/BaseSettingsPanel';
import { logAsync } from '../../../logger';
import { showMessage } from '../../../ui/toast';
import type { ExtensionSettings } from '../../../../types';
import type { SettingsValidationResult, SettingsSaveResult } from '../types';
import { saveSettings } from '../../../../utils/storage';

/**
 * WebDAVè®¾ç½®é¢æ¿ç±»
 */
export class WebDAVSettings extends BaseSettingsPanel {
    private webdavEnabled!: HTMLInputElement;
    private webdavAutoSync!: HTMLInputElement;
    private webdavSyncInterval!: HTMLInputElement;
    private webdavRetentionDays!: HTMLInputElement;
    private webdavWarningDays!: HTMLInputElement;
    // æ•°æ®èŒƒå›´é€‰æ‹©
    private webdavBackupCoreData!: HTMLInputElement;
    private webdavBackupActorData!: HTMLInputElement;
    private webdavBackupNewWorksData!: HTMLInputElement;
    private webdavBackupSystemConfig!: HTMLInputElement;
    private webdavBackupLogsData!: HTMLInputElement;
    private saveWebdavSettingsBtn!: HTMLButtonElement;
    private testWebdavConnectionBtn!: HTMLButtonElement;
    private diagnoseWebdavConnectionBtn!: HTMLButtonElement;
    private lastSyncTime!: HTMLSpanElement;
    // é…ç½®ç®¡ç†
    private addWebdavConfigBtn!: HTMLButtonElement;
    private webdavConfigList!: HTMLDivElement;
    private webdavCurrentConfigHint!: HTMLDivElement;
    private webdavCurrentConfigText!: HTMLSpanElement;
    // å¼¹çª—å…ƒç´ 
    private configModal!: HTMLDivElement;
    private configModalTitle!: HTMLHeadingElement;
    private closeConfigModalBtn!: HTMLButtonElement;
    private cancelConfigModalBtn!: HTMLButtonElement;
    private saveConfigModalBtn!: HTMLButtonElement;
    private modalConfigName!: HTMLInputElement;
    private modalWebdavProvider!: HTMLSelectElement;
    private modalWebdavUrl!: HTMLInputElement;
    private modalWebdavFolder!: HTMLInputElement;
    private modalWebdavUser!: HTMLInputElement;
    private modalWebdavPass!: HTMLInputElement;
    private modalTogglePasswordBtn!: HTMLButtonElement;
    private modalCopyFullUrlBtn!: HTMLButtonElement;
    private modalCopyUserBtn!: HTMLButtonElement;
    private modalCopyPassBtn!: HTMLButtonElement;
    
    // å½“å‰ç¼–è¾‘çš„é…ç½®IDï¼ˆç”¨äºåŒºåˆ†æ·»åŠ /ç¼–è¾‘æ¨¡å¼ï¼‰
    private editingConfigId: string | null = null;

    private readonly onSaveClick = () => { this.handleSaveSettings().catch(() => {}); };
    private readonly onWebdavEnabledChange = () => { this.handleWebDAVEnabledChange(); };
    private readonly onWebdavAutoSyncChange = () => { this.handleWebDAVAutoSyncChange(); };
    private readonly onBackupRangeChange = () => { this.handleBackupRangeChange(); };
    private readonly onInputChange = () => { this.handleInputChange(); };
    private readonly onProviderChange = () => { this.handleProviderChange(); };
    private readonly onTestClick = () => { this.handleTestWebDAV().catch(() => {}); };
    private readonly onDiagnoseClick = () => { this.handleDiagnoseWebDAV().catch(() => {}); };
    private readonly onTogglePasswordClick = () => { this.handleTogglePasswordVisibility(); };
    private readonly onCopyFullUrlClick = () => { this.handleCopyFullUrl(); };
    private readonly onCopyUserClick = () => { this.handleCopyUser(); };
    private readonly onCopyPassClick = () => { this.handleCopyPass(); };
    private readonly onAddConfigClick = () => { this.handleAddConfig(); };

    constructor() {
        super({
            panelId: 'webdav-settings',
            panelName: 'WebDAVè®¾ç½®',
            autoSave: false, // WebDAVè®¾ç½®éœ€è¦æ‰‹åŠ¨ä¿å­˜
            requireValidation: true
        });
    }

    /**
     * åˆå§‹åŒ–DOMå…ƒç´ 
     */
    protected initializeElements(): void {
        this.webdavEnabled = document.getElementById('webdavEnabled') as HTMLInputElement;
        this.webdavProvider = document.getElementById('webdavProvider') as HTMLSelectElement;
        this.webdavUrl = document.getElementById('webdavUrl') as HTMLInputElement;
        this.webdavFolder = document.getElementById('webdavFolder') as HTMLInputElement;
        this.webdavUser = document.getElementById('webdavUser') as HTMLInputElement;
        this.webdavPass = document.getElementById('webdavPass') as HTMLInputElement;
        this.webdavAutoSync = document.getElementById('webdavAutoSync') as HTMLInputElement;
        this.webdavSyncInterval = document.getElementById('webdav-sync-interval') as HTMLInputElement;
        this.webdavRetentionDays = document.getElementById('webdav-retention-days') as HTMLInputElement;
        this.webdavWarningDays = document.getElementById('webdav-warning-days') as HTMLInputElement;
        // æ•°æ®èŒƒå›´é€‰æ‹©
        this.webdavBackupCoreData = document.getElementById('webdavBackupCoreData') as HTMLInputElement;
        this.webdavBackupActorData = document.getElementById('webdavBackupActorData') as HTMLInputElement;
        this.webdavBackupNewWorksData = document.getElementById('webdavBackupNewWorksData') as HTMLInputElement;
        this.webdavBackupSystemConfig = document.getElementById('webdavBackupSystemConfig') as HTMLInputElement;
        this.webdavBackupLogsData = document.getElementById('webdavBackupLogsData') as HTMLInputElement;
        this.saveWebdavSettingsBtn = document.getElementById('saveWebdavSettings') as HTMLButtonElement;
        this.testWebdavConnectionBtn = document.getElementById('testWebdavConnection') as HTMLButtonElement;
        this.diagnoseWebdavConnectionBtn = document.getElementById('diagnoseWebdavConnection') as HTMLButtonElement;
        this.toggleWebdavPasswordVisibilityBtn = document.getElementById('toggleWebdavPasswordVisibility') as HTMLButtonElement;
        this.copyWebdavFullUrlBtn = document.getElementById('copyWebdavFullUrl') as HTMLButtonElement;
        this.copyWebdavUserBtn = document.getElementById('copyWebdavUser') as HTMLButtonElement;
        this.copyWebdavPassBtn = document.getElementById('copyWebdavPass') as HTMLButtonElement;
        this.lastSyncTime = document.getElementById('last-sync-time') as HTMLSpanElement;
        this.addWebdavConfigBtn = document.getElementById('addWebdavConfig') as HTMLButtonElement;
        this.webdavConfigList = document.getElementById('webdavConfigList') as HTMLDivElement;
        this.webdavCurrentConfigHint = document.getElementById('webdavCurrentConfigHint') as HTMLDivElement;
        this.webdavCurrentConfigText = document.getElementById('webdavCurrentConfigText') as HTMLSpanElement;

        if (!this.webdavEnabled || !this.webdavProvider || !this.webdavUrl || !this.webdavFolder || !this.webdavUser || !this.webdavPass ||
            !this.saveWebdavSettingsBtn || !this.testWebdavConnectionBtn || !this.diagnoseWebdavConnectionBtn ||
            !this.toggleWebdavPasswordVisibilityBtn || !this.copyWebdavFullUrlBtn || !this.copyWebdavUserBtn || !this.copyWebdavPassBtn ||
            !this.webdavRetentionDays || !this.webdavWarningDays ||
            !this.webdavBackupCoreData || !this.webdavBackupActorData || !this.webdavBackupNewWorksData ||
            !this.webdavBackupSystemConfig || !this.webdavBackupLogsData || !this.addWebdavConfigBtn || !this.webdavConfigList ||
            !this.webdavCurrentConfigHint || !this.webdavCurrentConfigText) {
            throw new Error('WebDAVè®¾ç½®ç›¸å…³çš„DOMå…ƒç´ æœªæ‰¾åˆ°');
        }
    }

    /**
     * ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
     */
    protected bindEvents(): void {
        this.saveWebdavSettingsBtn.addEventListener('click', this.onSaveClick);
        this.webdavEnabled.addEventListener('change', this.onWebdavEnabledChange);
        this.webdavAutoSync.addEventListener('change', this.onWebdavAutoSyncChange);
        this.webdavProvider.addEventListener('change', this.onProviderChange);
        
        // ç»‘å®šè¾“å…¥æ¡†çš„è‡ªåŠ¨ä¿å­˜
        this.webdavSyncInterval.addEventListener('change', this.onInputChange);
        this.webdavRetentionDays.addEventListener('change', this.onInputChange);
        this.webdavWarningDays.addEventListener('change', this.onInputChange);
        
        // ç»‘å®šæ•°æ®èŒƒå›´å¤é€‰æ¡†çš„è‡ªåŠ¨ä¿å­˜
        this.webdavBackupCoreData.addEventListener('change', this.onBackupRangeChange);
        this.webdavBackupActorData.addEventListener('change', this.onBackupRangeChange);
        this.webdavBackupNewWorksData.addEventListener('change', this.onBackupRangeChange);
        this.webdavBackupSystemConfig.addEventListener('change', this.onBackupRangeChange);
        this.webdavBackupLogsData.addEventListener('change', this.onBackupRangeChange);
        
        this.testWebdavConnectionBtn.addEventListener('click', this.onTestClick);
        this.diagnoseWebdavConnectionBtn.addEventListener('click', this.onDiagnoseClick);
        this.toggleWebdavPasswordVisibilityBtn.addEventListener('click', this.onTogglePasswordClick);
        this.copyWebdavFullUrlBtn.addEventListener('click', this.onCopyFullUrlClick);
        this.copyWebdavUserBtn.addEventListener('click', this.onCopyUserClick);
        this.copyWebdavPassBtn.addEventListener('click', this.onCopyPassClick);
        this.addWebdavConfigBtn.addEventListener('click', this.onAddConfigClick);
    }

    /**
     * è§£ç»‘äº‹ä»¶ç›‘å¬å™¨
     */
    protected unbindEvents(): void {
        this.saveWebdavSettingsBtn?.removeEventListener('click', this.onSaveClick);
        this.webdavEnabled?.removeEventListener('change', this.onWebdavEnabledChange);
        this.webdavAutoSync?.removeEventListener('change', this.onWebdavAutoSyncChange);
        this.webdavProvider?.removeEventListener('change', this.onProviderChange);
        
        // è§£ç»‘è¾“å…¥æ¡†
        this.webdavSyncInterval?.removeEventListener('change', this.onInputChange);
        this.webdavRetentionDays?.removeEventListener('change', this.onInputChange);
        this.webdavWarningDays?.removeEventListener('change', this.onInputChange);
        
        // è§£ç»‘æ•°æ®èŒƒå›´å¤é€‰æ¡†
        this.webdavBackupCoreData?.removeEventListener('change', this.onBackupRangeChange);
        this.webdavBackupActorData?.removeEventListener('change', this.onBackupRangeChange);
        this.webdavBackupNewWorksData?.removeEventListener('change', this.onBackupRangeChange);
        this.webdavBackupSystemConfig?.removeEventListener('change', this.onBackupRangeChange);
        this.webdavBackupLogsData?.removeEventListener('change', this.onBackupRangeChange);
        this.testWebdavConnectionBtn?.removeEventListener('click', this.onTestClick);
        this.diagnoseWebdavConnectionBtn?.removeEventListener('click', this.onDiagnoseClick);
        this.toggleWebdavPasswordVisibilityBtn?.removeEventListener('click', this.onTogglePasswordClick);
        this.copyWebdavFullUrlBtn?.removeEventListener('click', this.onCopyFullUrlClick);
        this.copyWebdavUserBtn?.removeEventListener('click', this.onCopyUserClick);
        this.copyWebdavPassBtn?.removeEventListener('click', this.onCopyPassClick);
    }

    /**
     * åŠ è½½è®¾ç½®åˆ°UI
     */
    protected async doLoadSettings(): Promise<void> {
        const settings = STATE.settings;
        const webdav = settings?.webdav || {};

        // å…¼å®¹æ—§ç‰ˆæœ¬ï¼šå¦‚æœæœ‰æ—§é…ç½®ä½†æ²¡æœ‰ configsï¼Œè‡ªåŠ¨è¿ç§»
        if (webdav.url && webdav.username && (!webdav.configs || webdav.configs.length === 0)) {
            await this.migrateOldConfig();
            return; // è¿ç§»åé‡æ–°åŠ è½½
        }

        // æ¸²æŸ“é…ç½®åˆ—è¡¨
        this.renderConfigList();
        
        // æ›´æ–°å½“å‰é…ç½®æç¤º
        this.updateCurrentConfigHint();

        this.webdavEnabled.checked = webdav.enabled || false;
        
        // å¹³æ»‘è¿ç§»ï¼šæ‹†åˆ†ç°æœ‰ URL ä¸ºåŸºç¡€åœ°å€å’Œæ–‡ä»¶å¤¹
        const { baseUrl, folder } = this.splitUrl(webdav.url || '');
        this.webdavUrl.value = baseUrl;
        this.webdavFolder.value = folder;
        
        // æ ¹æ® URL è‡ªåŠ¨è¯†åˆ«å‚å•†
        this.detectProviderFromUrl(baseUrl);
        
        this.webdavUser.value = webdav.username || '';
        this.webdavPass.value = webdav.password || '';
        this.webdavAutoSync.checked = webdav.autoSync || false;
        this.webdavSyncInterval.value = String(webdav.syncInterval || 30);
        this.webdavRetentionDays.value = String(webdav.retentionDays ?? 7);
        this.webdavWarningDays.value = String(webdav.warningDays ?? 7);
        // åŠ è½½æ•°æ®èŒƒå›´è®¾ç½®
        const backupRange = webdav.backupRange || {
            coreData: true,
            actorData: true,
            newWorksData: false,
            systemConfig: true,
            logsData: false
        };
        this.webdavBackupCoreData.checked = backupRange.coreData !== false;
        this.webdavBackupActorData.checked = backupRange.actorData !== false;
        this.webdavBackupNewWorksData.checked = backupRange.newWorksData || false;
        this.webdavBackupSystemConfig.checked = backupRange.systemConfig !== false;
        this.webdavBackupLogsData.checked = backupRange.logsData || false;
        this.lastSyncTime.textContent = webdav.lastSync ? new Date(webdav.lastSync).toLocaleString() : 'Never';

        // æ›´æ–°UIçŠ¶æ€
        this.updateWebDAVControlsState();
        this.updateFieldsVisibility();
    }

    /**
     * ä¿å­˜è®¾ç½®
     * å¦‚æœæœ‰æ¿€æ´»çš„é…ç½®ï¼Œæ›´æ–°è¯¥é…ç½®ï¼›å¦‚æœæ²¡æœ‰æ¿€æ´»é…ç½®ä½†å¡«å†™äº†ä¿¡æ¯ï¼Œåˆ›å»ºæ–°é…ç½®
     */
    protected async doSaveSettings(): Promise<SettingsSaveResult> {
        try {
            // åˆå¹¶åŸºç¡€åœ°å€å’Œæ–‡ä»¶å¤¹ä¸ºå®Œæ•´ URL
            const fullUrl = this.combineUrl(this.webdavUrl.value.trim(), this.webdavFolder.value.trim());
            
            const settings = STATE.settings;
            const configs = settings?.webdav?.configs || [];
            const activeConfigId = settings?.webdav?.activeConfigId;

            // å¦‚æœæœ‰æ¿€æ´»çš„é…ç½®ï¼Œæ›´æ–°å®ƒ
            if (activeConfigId) {
                const configIndex = configs.findIndex(c => c.id === activeConfigId);
                if (configIndex !== -1) {
                    configs[configIndex] = {
                        ...configs[configIndex],
                        url: fullUrl,
                        username: this.webdavUser.value.trim(),
                        password: this.webdavPass.value,
                        provider: this.webdavProvider.value as any,
                        updatedAt: Date.now()
                    };
                }
            } else if (fullUrl && this.webdavUser.value.trim() && this.webdavPass.value) {
                // å¦‚æœæ²¡æœ‰æ¿€æ´»é…ç½®ä½†å¡«å†™äº†å®Œæ•´ä¿¡æ¯ï¼Œåˆ›å»ºæ–°é…ç½®
                const newConfig: import('../../../../types').WebDAVConfig = {
                    id: `config_${Date.now()}`,
                    name: 'é»˜è®¤é…ç½®',
                    url: fullUrl,
                    username: this.webdavUser.value.trim(),
                    password: this.webdavPass.value,
                    provider: this.webdavProvider.value as any,
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    lastSync: null
                };
                configs.push(newConfig);
                
                const newSettings: ExtensionSettings = {
                    ...STATE.settings,
                    webdav: {
                        enabled: this.webdavEnabled.checked,
                        url: fullUrl,
                        username: this.webdavUser.value.trim(),
                        password: this.webdavPass.value,
                        autoSync: this.webdavAutoSync.checked,
                        syncInterval: parseInt(this.webdavSyncInterval.value, 10),
                        retentionDays: parseInt(this.webdavRetentionDays.value, 10),
                        warningDays: parseInt(this.webdavWarningDays.value, 10),
                        lastSync: STATE.settings?.webdav?.lastSync || null,
                        backupRange: {
                            coreData: this.webdavBackupCoreData.checked,
                            actorData: this.webdavBackupActorData.checked,
                            newWorksData: this.webdavBackupNewWorksData.checked,
                            systemConfig: this.webdavBackupSystemConfig.checked,
                            logsData: this.webdavBackupLogsData.checked
                        },
                        configs,
                        activeConfigId: newConfig.id
                    }
                };

                await saveSettings(newSettings);
                STATE.settings = newSettings;
                this.renderConfigList();
                this.updateCurrentConfigHint();

                // è®¾ç½®å®šæ—¶å™¨
                chrome.runtime.sendMessage({ type: 'setup-alarms' });

                return {
                    success: true,
                    savedSettings: { webdav: newSettings.webdav }
                };
            }
            
            const newSettings: ExtensionSettings = {
                ...STATE.settings,
                webdav: {
                    enabled: this.webdavEnabled.checked,
                    url: fullUrl,
                    username: this.webdavUser.value.trim(),
                    password: this.webdavPass.value,
                    autoSync: this.webdavAutoSync.checked,
                    syncInterval: parseInt(this.webdavSyncInterval.value, 10),
                    retentionDays: parseInt(this.webdavRetentionDays.value, 10),
                    warningDays: parseInt(this.webdavWarningDays.value, 10),
                    lastSync: STATE.settings?.webdav?.lastSync || null,
                    backupRange: {
                        coreData: this.webdavBackupCoreData.checked,
                        actorData: this.webdavBackupActorData.checked,
                        newWorksData: this.webdavBackupNewWorksData.checked,
                        systemConfig: this.webdavBackupSystemConfig.checked,
                        logsData: this.webdavBackupLogsData.checked
                    },
                    configs,
                    activeConfigId
                }
            };

            await saveSettings(newSettings);
            STATE.settings = newSettings;
            this.renderConfigList();
            this.updateCurrentConfigHint();

            // è®¾ç½®å®šæ—¶å™¨
            chrome.runtime.sendMessage({ type: 'setup-alarms' });

            return {
                success: true,
                savedSettings: { webdav: newSettings.webdav }
            };
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : 'ä¿å­˜å¤±è´¥'
            };
        }
    }

    /**
     * éªŒè¯è®¾ç½®
     */
    protected doValidateSettings(): SettingsValidationResult {
        const errors: string[] = [];
        const warnings: string[] = [];

        if (this.webdavEnabled.checked) {
            if (!this.webdavUrl.value.trim()) {
                errors.push('WebDAVæœåŠ¡å™¨åœ°å€ä¸èƒ½ä¸ºç©º');
            } else if (!this.webdavUrl.value.startsWith('http')) {
                errors.push('WebDAVæœåŠ¡å™¨åœ°å€å¿…é¡»ä»¥http://æˆ–https://å¼€å¤´');
            }

            if (!this.webdavUser.value.trim()) {
                errors.push('WebDAVç”¨æˆ·åä¸èƒ½ä¸ºç©º');
            }

            if (!this.webdavPass.value) {
                errors.push('WebDAVå¯†ç ä¸èƒ½ä¸ºç©º');
            }

            const syncInterval = parseInt(this.webdavSyncInterval.value, 10);
            if (isNaN(syncInterval) || syncInterval < 5 || syncInterval > 1440) {
                errors.push('åŒæ­¥é—´éš”å¿…é¡»åœ¨5-1440åˆ†é’Ÿä¹‹é—´');
            }

            const days = parseInt(this.webdavRetentionDays.value, 10);
            if (isNaN(days) || days < 0 || days > 3650) {
                errors.push('ä¿ç•™å¤‡ä»½å¤©æ•°å¿…é¡»åœ¨0-3650ä¹‹é—´');
            }

            const warnDays = parseInt(this.webdavWarningDays.value, 10);
            if (isNaN(warnDays) || warnDays < 0 || warnDays > 3650) {
                errors.push('æœªå¤‡ä»½é¢„è­¦é˜ˆå€¼å¿…é¡»åœ¨0-3650ä¹‹é—´');
            }

            // éªŒè¯è‡³å°‘é€‰æ‹©ä¸€é¡¹å¤‡ä»½å†…å®¹
            const hasBackupContent = this.webdavBackupCoreData.checked ||
                                    this.webdavBackupActorData.checked ||
                                    this.webdavBackupNewWorksData.checked ||
                                    this.webdavBackupSystemConfig.checked ||
                                    this.webdavBackupLogsData.checked;
            
            if (!hasBackupContent) {
                errors.push('è¯·è‡³å°‘é€‰æ‹©ä¸€é¡¹è¦å¤‡ä»½çš„æ•°æ®');
            }
        }

        return {
            isValid: errors.length === 0,
            errors: errors.length > 0 ? errors : undefined,
            warnings: warnings.length > 0 ? warnings : undefined
        };
    }

    /**
     * è·å–å½“å‰è®¾ç½®
     */
    protected doGetSettings(): Partial<ExtensionSettings> {
        // åˆå¹¶åŸºç¡€åœ°å€å’Œæ–‡ä»¶å¤¹ä¸ºå®Œæ•´ URL
        const fullUrl = this.combineUrl(this.webdavUrl.value.trim(), this.webdavFolder.value.trim());
        
        return {
            webdav: {
                enabled: this.webdavEnabled.checked,
                url: fullUrl,
                username: this.webdavUser.value.trim(),
                password: this.webdavPass.value,
                autoSync: this.webdavAutoSync.checked,
                syncInterval: parseInt(this.webdavSyncInterval.value, 10),
                retentionDays: parseInt(this.webdavRetentionDays.value, 10),
                warningDays: parseInt(this.webdavWarningDays.value, 10),
                lastSync: STATE.settings?.webdav?.lastSync || '',
                backupRange: {
                    coreData: this.webdavBackupCoreData.checked,
                    actorData: this.webdavBackupActorData.checked,
                    newWorksData: this.webdavBackupNewWorksData.checked,
                    systemConfig: this.webdavBackupSystemConfig.checked,
                    logsData: this.webdavBackupLogsData.checked
                }
            }
        };
    }

    /**
     * è®¾ç½®æ•°æ®åˆ°UI
     */
    protected doSetSettings(settings: Partial<ExtensionSettings>): void {
        const webdav = settings.webdav;
        if (webdav) {
            if (webdav.enabled !== undefined) {
                this.webdavEnabled.checked = webdav.enabled;
            }
            if (webdav.url !== undefined) {
                // æ‹†åˆ† URL ä¸ºåŸºç¡€åœ°å€å’Œæ–‡ä»¶å¤¹
                const { baseUrl, folder } = this.splitUrl(webdav.url);
                this.webdavUrl.value = baseUrl;
                this.webdavFolder.value = folder;
                this.detectProviderFromUrl(baseUrl);
            }
            if (webdav.username !== undefined) {
                this.webdavUser.value = webdav.username;
            }
            if (webdav.password !== undefined) {
                this.webdavPass.value = webdav.password;
            }
            if (webdav.autoSync !== undefined) {
                this.webdavAutoSync.checked = webdav.autoSync;
            }
            if (webdav.syncInterval !== undefined) {
                this.webdavSyncInterval.value = String(webdav.syncInterval);
            }
            if (webdav.retentionDays !== undefined) {
                this.webdavRetentionDays.value = String(webdav.retentionDays);
            }
            if (webdav.warningDays !== undefined) {
                this.webdavWarningDays.value = String(webdav.warningDays);
            }
            if (webdav.backupRange !== undefined) {
                const range = webdav.backupRange;
                this.webdavBackupCoreData.checked = range.coreData !== false;
                this.webdavBackupActorData.checked = range.actorData !== false;
                this.webdavBackupNewWorksData.checked = range.newWorksData || false;
                this.webdavBackupSystemConfig.checked = range.systemConfig !== false;
                this.webdavBackupLogsData.checked = range.logsData || false;
            }
            if (webdav.lastSync !== undefined) {
                this.lastSyncTime.textContent = webdav.lastSync ? new Date(webdav.lastSync).toLocaleString() : 'Never';
            }

            this.updateWebDAVControlsState();
            this.updateFieldsVisibility();
        }
    }

    /**
     * å¤„ç†ä¿å­˜è®¾ç½®æŒ‰é’®ç‚¹å‡»
     */
    private async handleSaveSettings(): Promise<void> {
        try {
            await this.saveSettings();
            // åŸºç±»çš„ saveSettings æ–¹æ³•ä¼šè‡ªåŠ¨æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤æ˜¾ç¤º
        } catch (error) {
            console.error('ä¿å­˜WebDAVè®¾ç½®å¤±è´¥:', error);
            showMessage('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
        }
    }

    /**
     * å¤„ç†WebDAVå¯ç”¨çŠ¶æ€å˜åŒ–
     */
    private handleWebDAVEnabledChange(): void {
        this.updateWebDAVControlsState();
        this.updateFieldsVisibility();
        this.emit('change');

        if (!this.webdavEnabled.checked) {
            this.saveSettings().catch(() => {});
        }
    }

    private handleWebDAVAutoSyncChange(): void {
        this.emit('change');
        this.saveSettings().catch(() => {});
    }

    /**
     * å¤„ç†å¤‡ä»½æ•°æ®èŒƒå›´å˜åŒ–
     */
    private handleBackupRangeChange(): void {
        this.emit('change');
        this.saveSettings().catch(() => {});
    }

    /**
     * æ›´æ–°WebDAVæ§ä»¶çŠ¶æ€
     */
    private updateWebDAVControlsState(): void {
        const webdavSubControls = document.getElementById('webdavSubControls');
        if (webdavSubControls) {
            if (this.webdavEnabled.checked) {
                webdavSubControls.classList.add('enabled');
            } else {
                webdavSubControls.classList.remove('enabled');
            }
        }
    }

    /**
     * æ›´æ–°å­—æ®µæ˜¾ç¤º/éšè—
     */
    private updateFieldsVisibility(): void {
        const fieldsContainer = document.getElementById('webdav-fields-container') as HTMLDivElement;
        if (fieldsContainer) {
            fieldsContainer.style.display = this.webdavEnabled.checked ? 'block' : 'none';
        }
    }

    /**
     * å¤„ç†æµ‹è¯•WebDAVè¿æ¥
     */
    private async handleTestWebDAV(): Promise<void> {
        logAsync('INFO', 'ç”¨æˆ·ç‚¹å‡»äº†"æµ‹è¯• WebDAV è¿æ¥"æŒ‰é’®ã€‚');
        
        try {
            await this.saveSettings();
            logAsync('INFO', 'ç”¨æˆ·å¼€å§‹æµ‹è¯•WebDAVè¿æ¥');
            showMessage('æ­£åœ¨æµ‹è¯•è¿æ¥...', 'info');
            this.testWebdavConnectionBtn.textContent = 'è¿æ¥æµ‹è¯•ä¸­...';
            this.testWebdavConnectionBtn.disabled = true;

            logAsync('INFO', 'æ­£åœ¨å‘åå°å‘é€WebDAVè¿æ¥æµ‹è¯•è¯·æ±‚');

            chrome.runtime.sendMessage({ type: 'webdav-test' }, response => {
                if (response && response.success) {
                    showMessage('ğŸ‰ WebDAVè¿æ¥æµ‹è¯•æˆåŠŸï¼æœåŠ¡å™¨å“åº”æ­£å¸¸', 'success');
                    logAsync('INFO', 'WebDAVè¿æ¥æµ‹è¯•æˆåŠŸï¼ŒæœåŠ¡å™¨è®¤è¯é€šè¿‡');
                } else {
                    const errorMsg = response?.error || 'æœªçŸ¥é”™è¯¯';
                    const userFriendlyMsg = this.getErrorMessage(errorMsg);
                    showMessage(userFriendlyMsg, 'error');
                    logAsync('ERROR', `WebDAVè¿æ¥æµ‹è¯•å¤±è´¥ï¼š${errorMsg}`, {
                        originalError: errorMsg,
                        userMessage: userFriendlyMsg
                    });
                }

                this.testWebdavConnectionBtn.textContent = 'æµ‹è¯•è¿æ¥';
                this.testWebdavConnectionBtn.disabled = false;
            });
        } catch (error) {
            showMessage('âŒ æ— æ³•è¿›è¡Œè¿æ¥æµ‹è¯•', 'error');
            logAsync('ERROR', `WebDAVè¿æ¥æµ‹è¯•å¤±è´¥ï¼š${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`);
            this.testWebdavConnectionBtn.textContent = 'æµ‹è¯•è¿æ¥';
            this.testWebdavConnectionBtn.disabled = false;
        }
    }

    /**
     * å¤„ç†è¯Šæ–­WebDAVè¿æ¥
     */
    private async handleDiagnoseWebDAV(): Promise<void> {
        logAsync('INFO', 'ç”¨æˆ·ç‚¹å‡»äº†"è¯Šæ–­ WebDAV è¿æ¥"æŒ‰é’®ã€‚');
        
        try {
            await this.saveSettings();
            logAsync('INFO', 'ç”¨æˆ·å¼€å§‹è¯Šæ–­WebDAVè¿æ¥');
            showMessage('æ­£åœ¨è¿›è¡Œè¯¦ç»†è¯Šæ–­...', 'info');
            this.diagnoseWebdavConnectionBtn.textContent = 'è¯Šæ–­ä¸­...';
            this.diagnoseWebdavConnectionBtn.disabled = true;

            logAsync('INFO', 'æ­£åœ¨å‘åå°å‘é€WebDAVè¯Šæ–­è¯·æ±‚');

            chrome.runtime.sendMessage({ type: 'webdav-diagnose' }, response => {
                if (response && response.success) {
                    const resultMessage = this.formatDiagnosticResult(response.diagnostic);
                    alert(resultMessage);

                    if (response.diagnostic.success) {
                        showMessage('âœ… è¯Šæ–­å®Œæˆï¼Œè¿æ¥æ­£å¸¸', 'success');
                        logAsync('INFO', 'WebDAVè¯Šæ–­æˆåŠŸ', response.diagnostic);
                    } else {
                        showMessage('âš ï¸ è¯Šæ–­å®Œæˆï¼Œå‘ç°é—®é¢˜ï¼Œè¯·æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯', 'warn');
                        logAsync('WARN', 'WebDAVè¯Šæ–­å‘ç°é—®é¢˜', response.diagnostic);
                    }
                } else {
                    const errorMsg = response?.error || 'è¯Šæ–­å¤±è´¥';
                    showMessage(`âŒ WebDAVè¯Šæ–­å¤±è´¥ï¼š${errorMsg}`, 'error');
                    logAsync('ERROR', `WebDAVè¯Šæ–­å¤±è´¥ï¼š${errorMsg}`);
                }

                this.diagnoseWebdavConnectionBtn.textContent = 'è¯Šæ–­è¿æ¥';
                this.diagnoseWebdavConnectionBtn.disabled = false;
            });
        } catch (error) {
            showMessage('âŒ æ— æ³•è¿›è¡Œè¯Šæ–­', 'error');
            logAsync('ERROR', `WebDAVè¯Šæ–­å¤±è´¥ï¼š${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`);
            this.diagnoseWebdavConnectionBtn.textContent = 'è¯Šæ–­è¿æ¥';
            this.diagnoseWebdavConnectionBtn.disabled = false;
        }
    }

    /**
     * è·å–å‹å¥½çš„é”™è¯¯ä¿¡æ¯
     */
    private getErrorMessage(errorMsg: string): string {
        if (errorMsg.includes('401')) {
            return 'âŒ WebDAVè¿æ¥å¤±è´¥ï¼šç”¨æˆ·åæˆ–å¯†ç é”™è¯¯ï¼Œè¯·æ£€æŸ¥è®¤è¯ä¿¡æ¯';
        } else if (errorMsg.includes('404')) {
            return 'âŒ WebDAVè¿æ¥å¤±è´¥ï¼šæœåŠ¡å™¨åœ°å€ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æ­£ç¡®';
        } else if (errorMsg.includes('403')) {
            return 'âŒ WebDAVè¿æ¥å¤±è´¥ï¼šæ²¡æœ‰è®¿é—®æƒé™ï¼Œè¯·æ£€æŸ¥è´¦æˆ·æƒé™è®¾ç½®';
        } else if (errorMsg.includes('timeout') || errorMsg.includes('ç½‘ç»œ')) {
            return 'âŒ WebDAVè¿æ¥å¤±è´¥ï¼šç½‘ç»œè¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒæœåŠ¡å™¨çŠ¶æ€';
        } else if (errorMsg.includes('not fully configured')) {
            return 'âŒ WebDAVè¿æ¥å¤±è´¥ï¼šé…ç½®ä¿¡æ¯ä¸å®Œæ•´ï¼Œè¯·å¡«å†™å®Œæ•´çš„æœåŠ¡å™¨åœ°å€ã€ç”¨æˆ·åå’Œå¯†ç ';
        } else {
            return `âŒ WebDAVè¿æ¥å¤±è´¥ï¼š${errorMsg}`;
        }
    }

    /**
     * æ ¼å¼åŒ–è¯Šæ–­ç»“æœ
     */
    private formatDiagnosticResult(diagnostic: any): string {
        let resultMessage = 'ğŸ” WebDAVè¿æ¥è¯Šæ–­å®Œæˆ\n\n';

        if (diagnostic.serverType) {
            resultMessage += `ğŸ“¡ æœåŠ¡å™¨ç±»å‹: ${diagnostic.serverType}\n`;
        }

        if (diagnostic.supportedMethods && diagnostic.supportedMethods.length > 0) {
            resultMessage += `ğŸ› ï¸ æ”¯æŒçš„æ–¹æ³•: ${diagnostic.supportedMethods.join(', ')}\n`;
        }

        if (diagnostic.responseFormat) {
            resultMessage += `ğŸ“„ å“åº”æ ¼å¼: ${diagnostic.responseFormat}\n`;
        }

        if (diagnostic.issues && diagnostic.issues.length > 0) {
            resultMessage += `\nâš ï¸ å‘ç°çš„é—®é¢˜:\n`;
            diagnostic.issues.forEach((issue: string, index: number) => {
                resultMessage += `${index + 1}. ${issue}\n`;
            });
        }

        if (diagnostic.recommendations && diagnostic.recommendations.length > 0) {
            resultMessage += `\nğŸ’¡ å»ºè®®:\n`;
            diagnostic.recommendations.forEach((rec: string, index: number) => {
                resultMessage += `${index + 1}. ${rec}\n`;
            });
        }

        return resultMessage;
    }

    /**
     * å¤„ç†å¯†ç å¯è§æ€§åˆ‡æ¢
     */
    private handleTogglePasswordVisibility(): void {
        const isPassword = this.webdavPass.type === 'password';
        this.webdavPass.type = isPassword ? 'text' : 'password';

        const icon = this.toggleWebdavPasswordVisibilityBtn.querySelector('i');
        if (icon) {
            icon.className = isPassword ? 'fas fa-eye-slash' : 'fas fa-eye';
        }

        // æ›´æ–°æŒ‰é’®æ ‡é¢˜
        this.toggleWebdavPasswordVisibilityBtn.title = isPassword ? 'éšè—å¯†ç ' : 'æ˜¾ç¤ºå¯†ç ';
    }

    /**
     * å¤„ç†è¾“å…¥æ¡†å˜åŒ–ï¼ˆåŒæ­¥é—´éš”ã€ä¿ç•™å¤©æ•°ã€é¢„è­¦é˜ˆå€¼ï¼‰
     */
    private handleInputChange(): void {
        this.emit('change');
        this.saveSettings().catch(() => {});
    }

    /**
     * å¤åˆ¶å®Œæ•´ WebDAV åœ°å€
     */
    private handleCopyFullUrl(): void {
        const fullUrl = this.combineUrl(this.webdavUrl.value.trim(), this.webdavFolder.value.trim());
        if (!fullUrl) {
            showMessage('åœ°å€ä¸ºç©ºï¼Œæ— æ³•å¤åˆ¶', 'warn');
            return;
        }

        navigator.clipboard.writeText(fullUrl).then(() => {
            showMessage('âœ“ å·²å¤åˆ¶å®Œæ•´åœ°å€', 'success');
            logAsync('INFO', 'ç”¨æˆ·å¤åˆ¶äº† WebDAV å®Œæ•´åœ°å€');
        }).catch(() => {
            showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
        });
    }

    /**
     * å¤åˆ¶ç”¨æˆ·å
     */
    private handleCopyUser(): void {
        const username = this.webdavUser.value.trim();
        if (!username) {
            showMessage('ç”¨æˆ·åä¸ºç©ºï¼Œæ— æ³•å¤åˆ¶', 'warn');
            return;
        }

        navigator.clipboard.writeText(username).then(() => {
            showMessage('âœ“ å·²å¤åˆ¶ç”¨æˆ·å', 'success');
            logAsync('INFO', 'ç”¨æˆ·å¤åˆ¶äº† WebDAV ç”¨æˆ·å');
        }).catch(() => {
            showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
        });
    }

    /**
     * å¤åˆ¶å¯†ç 
     */
    private handleCopyPass(): void {
        const password = this.webdavPass.value;
        if (!password) {
            showMessage('å¯†ç ä¸ºç©ºï¼Œæ— æ³•å¤åˆ¶', 'warn');
            return;
        }

        navigator.clipboard.writeText(password).then(() => {
            showMessage('âœ“ å·²å¤åˆ¶å¯†ç ', 'success');
            logAsync('INFO', 'ç”¨æˆ·å¤åˆ¶äº† WebDAV å¯†ç ');
        }).catch(() => {
            showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
        });
    }

    /**
     * å¤„ç†å‚å•†é€‰æ‹©å˜åŒ–
     */
    private handleProviderChange(): void {
        const provider = this.webdavProvider.value;
        
        // æ ¹æ®å‚å•†é¢„è®¾ URL
        switch (provider) {
            case 'jianguoyun':
                this.webdavUrl.value = 'https://dav.jianguoyun.com/dav/';
                showMessage('å·²è‡ªåŠ¨å¡«å……åšæœäº‘æœåŠ¡å™¨åœ°å€', 'info');
                break;
            case 'teracloud':
                this.webdavUrl.value = 'https://ogi.teracloud.jp/dav/';
                showMessage('å·²è‡ªåŠ¨å¡«å…… TeraCloud æœåŠ¡å™¨åœ°å€', 'info');
                break;
            case 'custom':
                // è‡ªå®šä¹‰æ¨¡å¼ï¼Œä¸ä¿®æ”¹ URL
                break;
        }
        
        this.emit('change');
    }

    /**
     * æ ¹æ® URL è‡ªåŠ¨è¯†åˆ«å‚å•†
     */
    private detectProviderFromUrl(url: string): void {
        if (!url) {
            this.webdavProvider.value = 'custom';
            return;
        }

        if (url.includes('jianguoyun.com')) {
            this.webdavProvider.value = 'jianguoyun';
        } else if (url.includes('teracloud.jp')) {
            this.webdavProvider.value = 'teracloud';
        } else {
            this.webdavProvider.value = 'custom';
        }
    }

    /**
     * æ‹†åˆ†å®Œæ•´ URL ä¸ºåŸºç¡€åœ°å€å’Œæ–‡ä»¶å¤¹
     * ä¾‹å¦‚: https://ogi.teracloud.jp/dav/javjav -> { baseUrl: 'https://ogi.teracloud.jp/dav/', folder: 'javjav' }
     */
    private splitUrl(fullUrl: string): { baseUrl: string; folder: string } {
        if (!fullUrl) {
            return { baseUrl: '', folder: '' };
        }

        // è¯†åˆ«å·²çŸ¥å‚å•†çš„åŸºç¡€è·¯å¾„
        const knownBases = [
            'https://dav.jianguoyun.com/dav/',
            'https://ogi.teracloud.jp/dav/'
        ];

        for (const base of knownBases) {
            if (fullUrl.startsWith(base)) {
                const folder = fullUrl.substring(base.length).replace(/\/$/, ''); // ç§»é™¤æœ«å°¾æ–œæ 
                return { baseUrl: base, folder };
            }
        }

        // è‡ªå®šä¹‰ URLï¼šå°è¯•æ™ºèƒ½æ‹†åˆ†
        // å¦‚æœ URL ä»¥ /dav/ ç»“å°¾ï¼Œè®¤ä¸ºæ˜¯åŸºç¡€åœ°å€
        if (fullUrl.endsWith('/dav/')) {
            return { baseUrl: fullUrl, folder: '' };
        }

        // æŸ¥æ‰¾æœ€åä¸€ä¸ª /dav/ çš„ä½ç½®
        const davIndex = fullUrl.lastIndexOf('/dav/');
        if (davIndex !== -1) {
            const baseUrl = fullUrl.substring(0, davIndex + 5); // åŒ…å« /dav/
            const folder = fullUrl.substring(davIndex + 5).replace(/\/$/, '');
            return { baseUrl, folder };
        }

        // å¦‚æœæ²¡æœ‰ /dav/ï¼Œå°è¯•æ‰¾æœ€åä¸€ä¸ªç›®å½•åˆ†éš”ç¬¦
        const lastSlashIndex = fullUrl.lastIndexOf('/');
        if (lastSlashIndex > 8) { // ç¡®ä¿ä¸æ˜¯åè®®éƒ¨åˆ†çš„æ–œæ 
            const possibleBase = fullUrl.substring(0, lastSlashIndex + 1);
            const possibleFolder = fullUrl.substring(lastSlashIndex + 1);
            
            // å¦‚æœå¯èƒ½çš„æ–‡ä»¶å¤¹éƒ¨åˆ†ä¸åŒ…å«ç‚¹ï¼ˆä¸åƒæ˜¯åŸŸåï¼‰ï¼Œåˆ™æ‹†åˆ†
            if (possibleFolder && !possibleFolder.includes('.')) {
                return { baseUrl: possibleBase, folder: possibleFolder };
            }
        }

        // æ— æ³•æ‹†åˆ†ï¼Œå…¨éƒ¨ä½œä¸ºåŸºç¡€åœ°å€
        return { baseUrl: fullUrl, folder: '' };
    }

    /**
     * åˆå¹¶åŸºç¡€åœ°å€å’Œæ–‡ä»¶å¤¹ä¸ºå®Œæ•´ URL
     */
    private combineUrl(baseUrl: string, folder: string): string {
        if (!baseUrl) {
            return '';
        }

        if (!folder) {
            return baseUrl;
        }

        // ç¡®ä¿åŸºç¡€åœ°å€ä»¥æ–œæ ç»“å°¾
        const normalizedBase = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';
        // ç§»é™¤æ–‡ä»¶å¤¹å¼€å¤´å’Œç»“å°¾çš„æ–œæ 
        const normalizedFolder = folder.replace(/^\/+|\/+$/g, '');
        
        return normalizedBase + normalizedFolder;
    }

    /**
     * æ›´æ–°å½“å‰é…ç½®æç¤º
     */
    private updateCurrentConfigHint(): void {
        const settings = STATE.settings;
        const activeConfigId = settings?.webdav?.activeConfigId;
        const configs = settings?.webdav?.configs || [];
        const activeConfig = configs.find(c => c.id === activeConfigId);

        if (activeConfig) {
            this.webdavCurrentConfigHint.style.display = 'flex';
            this.webdavCurrentConfigText.textContent = `å½“å‰ç¼–è¾‘ï¼š${activeConfig.name}`;
            
            // æ›´æ–°ä¿å­˜æŒ‰é’®æ–‡æ¡ˆ
            this.saveWebdavSettingsBtn.innerHTML = `<i class="fas fa-save"></i> ä¿å­˜å¹¶æ›´æ–°ï¼š${activeConfig.name}`;
        } else {
            this.webdavCurrentConfigHint.style.display = 'none';
            this.webdavCurrentConfigText.textContent = 'å½“å‰ç¼–è¾‘ï¼šæ— é…ç½®';
            
            // æ¢å¤é»˜è®¤æŒ‰é’®æ–‡æ¡ˆ
            this.saveWebdavSettingsBtn.innerHTML = '<i class="fas fa-save"></i> ä¿å­˜è®¾ç½®';
        }
    }

    /**
     * æ¸²æŸ“é…ç½®åˆ—è¡¨
     */
    private renderConfigList(): void {
        const settings = STATE.settings;
        const configs = settings?.webdav?.configs || [];
        const activeConfigId = settings?.webdav?.activeConfigId;

        if (configs.length === 0) {
            this.webdavConfigList.innerHTML = `
                <div class="webdav-config-empty">
                    <i class="fas fa-cloud"></i>
                    <p>æš‚æ— ä¿å­˜çš„é…ç½®ï¼Œç‚¹å‡»"æ·»åŠ é…ç½®"åˆ›å»ºæ–°é…ç½®</p>
                </div>
            `;
            return;
        }

        this.webdavConfigList.innerHTML = configs.map(config => {
            const isActive = config.id === activeConfigId;
            const providerName = config.provider === 'jianguoyun' ? 'åšæœäº‘' : 
                                config.provider === 'teracloud' ? 'TeraCloud' : 'è‡ªå®šä¹‰';
            
            return `
                <div class="webdav-config-item ${isActive ? 'active' : ''}" data-config-id="${config.id}">
                    <div class="config-radio">
                        <input type="radio" name="webdav-config" value="${config.id}" ${isActive ? 'checked' : ''}>
                    </div>
                    <div class="config-info">
                        <div class="config-name">${this.escapeHtml(config.name)}</div>
                        <div class="config-details">
                            <span class="config-detail-item">
                                <i class="fas fa-server"></i>
                                ${providerName}
                            </span>
                            <span class="config-detail-item">
                                <i class="fas fa-user"></i>
                                ${this.escapeHtml(config.username)}
                            </span>
                            ${config.lastSync ? `
                                <span class="config-detail-item">
                                    <i class="fas fa-clock"></i>
                                    ${new Date(config.lastSync).toLocaleString()}
                                </span>
                            ` : ''}
                        </div>
                    </div>
                    <div class="config-actions">
                        <button type="button" class="config-action-btn edit" data-action="edit" title="ç¼–è¾‘">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button type="button" class="config-action-btn delete" data-action="delete" title="åˆ é™¤">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        }).join('');

        // ç»‘å®šäº‹ä»¶
        this.webdavConfigList.querySelectorAll('input[type="radio"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const target = e.target as HTMLInputElement;
                this.handleSwitchConfig(target.value);
            });
        });

        this.webdavConfigList.querySelectorAll('.config-action-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const target = e.currentTarget as HTMLButtonElement;
                const action = target.dataset.action;
                const configItem = target.closest('.webdav-config-item') as HTMLElement;
                const configId = configItem?.dataset.configId;
                
                if (action === 'edit' && configId) {
                    this.handleEditConfig(configId);
                } else if (action === 'delete' && configId) {
                    this.handleDeleteConfig(configId);
                }
            });
        });
    }

    /**
     * æ·»åŠ æ–°é…ç½®
     * ä½¿ç”¨å½“å‰è¡¨å•çš„æ•°æ®åˆ›å»ºæ–°é…ç½®å¹¶åˆ‡æ¢åˆ°è¯¥é…ç½®
     */
    private handleAddConfig(): void {
        const fullUrl = this.combineUrl(this.webdavUrl.value.trim(), this.webdavFolder.value.trim());
        const username = this.webdavUser.value.trim();
        const password = this.webdavPass.value;

        if (!fullUrl || !username || !password) {
            showMessage('è¯·å…ˆå¡«å†™å®Œæ•´çš„ WebDAV é…ç½®ä¿¡æ¯ï¼ˆåœ°å€ã€ç”¨æˆ·åã€å¯†ç ï¼‰', 'warn');
            return;
        }

        const name = prompt('è¯·è¾“å…¥é…ç½®åç§°ï¼š', 'æ–°é…ç½®');
        if (!name || !name.trim()) {
            return;
        }

        const newConfig: import('../../../../types').WebDAVConfig = {
            id: `config_${Date.now()}`,
            name: name.trim(),
            url: fullUrl,
            username,
            password,
            provider: this.webdavProvider.value as any,
            createdAt: Date.now(),
            updatedAt: Date.now(),
            lastSync: null
        };

        const settings = STATE.settings;
        const configs = settings?.webdav?.configs || [];
        configs.push(newConfig);

        const newSettings: ExtensionSettings = {
            ...settings,
            webdav: {
                ...settings.webdav,
                configs,
                activeConfigId: newConfig.id,
                // åŒæ­¥æ›´æ–°ä¸»é…ç½®
                url: fullUrl,
                username,
                password
            }
        };

        saveSettings(newSettings).then(() => {
            STATE.settings = newSettings;
            this.renderConfigList();
            this.updateCurrentConfigHint();
            showMessage(`âœ“ é…ç½®"${newConfig.name}"å·²åˆ›å»ºå¹¶æ¿€æ´»`, 'success');
            logAsync('INFO', 'ç”¨æˆ·æ·»åŠ äº†æ–°çš„ WebDAV é…ç½®', { name: newConfig.name });
        }).catch(() => {
            showMessage('ä¿å­˜é…ç½®å¤±è´¥', 'error');
        });
    }

    /**
     * è¿ç§»æ—§ç‰ˆæœ¬é…ç½®
     */
    private async migrateOldConfig(): Promise<void> {
        const settings = STATE.settings;
        const webdav = settings?.webdav;

        if (!webdav || !webdav.url || !webdav.username) {
            return;
        }

        logAsync('INFO', 'æ£€æµ‹åˆ°æ—§ç‰ˆæœ¬ WebDAV é…ç½®ï¼Œå¼€å§‹è¿ç§»');

        const oldConfig: import('../../../../types').WebDAVConfig = {
            id: `config_${Date.now()}`,
            name: 'é»˜è®¤é…ç½®',
            url: webdav.url,
            username: webdav.username,
            password: webdav.password || '',
            provider: this.detectProviderType(webdav.url),
            createdAt: Date.now(),
            updatedAt: Date.now(),
            lastSync: webdav.lastSync || null
        };

        const newSettings = {
            ...settings,
            webdav: {
                ...webdav,
                configs: [oldConfig],
                activeConfigId: oldConfig.id
            }
        };

        try {
            await saveSettings(newSettings);
            STATE.settings = newSettings;
            this.renderConfigList();
            this.updateCurrentConfigHint();
            logAsync('INFO', 'æ—§ç‰ˆæœ¬ WebDAV é…ç½®è¿ç§»æˆåŠŸ');
            showMessage('âœ“ å·²è‡ªåŠ¨è¿ç§»æ—§é…ç½®', 'success');
            
            // é‡æ–°åŠ è½½è®¾ç½®
            await this.loadSettings();
        } catch (error) {
            logAsync('ERROR', 'æ—§ç‰ˆæœ¬ WebDAV é…ç½®è¿ç§»å¤±è´¥', { error });
            showMessage('é…ç½®è¿ç§»å¤±è´¥', 'error');
        }
    }

    /**
     * æ ¹æ® URL æ£€æµ‹å‚å•†ç±»å‹
     */
    private detectProviderType(url: string): 'jianguoyun' | 'teracloud' | 'custom' {
        if (url.includes('jianguoyun.com')) {
            return 'jianguoyun';
        } else if (url.includes('teracloud.jp')) {
            return 'teracloud';
        }
        return 'custom';
    }

    /**
     * åˆ‡æ¢é…ç½®
     */
    private handleSwitchConfig(configId: string): void {
        const settings = STATE.settings;
        const configs = settings?.webdav?.configs || [];
        const config = configs.find(c => c.id === configId);

        if (!config) {
            showMessage('é…ç½®ä¸å­˜åœ¨', 'error');
            return;
        }

        // æ›´æ–°å½“å‰è¡¨å•
        const { baseUrl, folder } = this.splitUrl(config.url);
        this.webdavUrl.value = baseUrl;
        this.webdavFolder.value = folder;
        this.webdavUser.value = config.username;
        this.webdavPass.value = config.password;
        this.detectProviderFromUrl(baseUrl);

        // ä¿å­˜æ¿€æ´»çš„é…ç½®IDå’Œå½“å‰é…ç½®åˆ°ä¸»é…ç½®
        const newSettings = {
            ...settings,
            webdav: {
                ...settings.webdav,
                activeConfigId: configId,
                url: config.url,
                username: config.username,
                password: config.password,
                lastSync: config.lastSync || settings.webdav?.lastSync || null
            }
        };

        saveSettings(newSettings).then(() => {
            STATE.settings = newSettings;
            this.renderConfigList();
            this.updateCurrentConfigHint();
            showMessage('âœ“ å·²åˆ‡æ¢åˆ°é…ç½®ï¼š' + config.name, 'success');
            logAsync('INFO', 'ç”¨æˆ·åˆ‡æ¢äº† WebDAV é…ç½®', { name: config.name });
        }).catch(() => {
            showMessage('åˆ‡æ¢é…ç½®å¤±è´¥', 'error');
        });
    }

    /**
     * ç¼–è¾‘é…ç½®
     */
    private handleEditConfig(configId: string): void {
        const settings = STATE.settings;
        const configs = settings?.webdav?.configs || [];
        const config = configs.find(c => c.id === configId);

        if (!config) {
            showMessage('é…ç½®ä¸å­˜åœ¨', 'error');
            return;
        }

        const newName = prompt('è¯·è¾“å…¥æ–°çš„é…ç½®åç§°ï¼š', config.name);
        if (!newName || !newName.trim()) {
            return;
        }

        config.name = newName.trim();
        config.updatedAt = Date.now();

        const newSettings = {
            ...settings,
            webdav: {
                ...settings.webdav,
                configs: [...configs]
            }
        };

        saveSettings(newSettings).then(() => {
            STATE.settings = newSettings;
            this.renderConfigList();
            this.updateCurrentConfigHint();
            showMessage('âœ“ é…ç½®å·²æ›´æ–°', 'success');
            logAsync('INFO', 'ç”¨æˆ·ç¼–è¾‘äº† WebDAV é…ç½®', { name: config.name });
        }).catch(() => {
            showMessage('æ›´æ–°é…ç½®å¤±è´¥', 'error');
        });
    }

    /**
     * åˆ é™¤é…ç½®
     */
    private handleDeleteConfig(configId: string): void {
        const settings = STATE.settings;
        const configs = settings?.webdav?.configs || [];
        const config = configs.find(c => c.id === configId);

        if (!config) {
            showMessage('é…ç½®ä¸å­˜åœ¨', 'error');
            return;
        }

        if (!confirm(`ç¡®å®šè¦åˆ é™¤é…ç½®"${config.name}"å—ï¼Ÿ`)) {
            return;
        }

        const newConfigs = configs.filter(c => c.id !== configId);
        let newActiveConfigId = settings.webdav?.activeConfigId;

        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ¿€æ´»çš„é…ç½®ï¼Œåˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªé…ç½®
        if (configId === newActiveConfigId) {
            newActiveConfigId = newConfigs.length > 0 ? newConfigs[0].id : undefined;
            
            // æ›´æ–°è¡¨å•ä¸ºæ–°çš„æ¿€æ´»é…ç½®
            if (newConfigs.length > 0) {
                const newActiveConfig = newConfigs[0];
                const { baseUrl, folder } = this.splitUrl(newActiveConfig.url);
                this.webdavUrl.value = baseUrl;
                this.webdavFolder.value = folder;
                this.webdavUser.value = newActiveConfig.username;
                this.webdavPass.value = newActiveConfig.password;
                this.detectProviderFromUrl(baseUrl);
            } else {
                // æ¸…ç©ºè¡¨å•
                this.webdavUrl.value = '';
                this.webdavFolder.value = '';
                this.webdavUser.value = '';
                this.webdavPass.value = '';
                this.webdavProvider.value = 'custom';
            }
        }

        const newSettings = {
            ...settings,
            webdav: {
                ...settings.webdav,
                configs: newConfigs,
                activeConfigId: newActiveConfigId,
                url: newConfigs.length > 0 && newActiveConfigId ? newConfigs.find(c => c.id === newActiveConfigId)?.url || '' : '',
                username: newConfigs.length > 0 && newActiveConfigId ? newConfigs.find(c => c.id === newActiveConfigId)?.username || '' : '',
                password: newConfigs.length > 0 && newActiveConfigId ? newConfigs.find(c => c.id === newActiveConfigId)?.password || '' : ''
            }
        };

        saveSettings(newSettings).then(() => {
            STATE.settings = newSettings;
            this.renderConfigList();
            this.updateCurrentConfigHint();
            showMessage('âœ“ é…ç½®å·²åˆ é™¤', 'success');
            logAsync('INFO', 'ç”¨æˆ·åˆ é™¤äº† WebDAV é…ç½®', { name: config.name });
        }).catch(() => {
            showMessage('åˆ é™¤é…ç½®å¤±è´¥', 'error');
        });
    }

    /**
     * HTML è½¬ä¹‰
     */
    private escapeHtml(text: string): string {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}
