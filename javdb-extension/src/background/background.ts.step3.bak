// src/background/background.ts
// ================= 115 v2 鍚庡彴浠ｇ悊锛堣В鍐冲唴瀹硅剼鏈?CORS锛?=================
);
          return true;
        }
      } else if (message.type === 'drive115.get_quota_info_v2') {
        try {
          const accessToken = String(message?.payload?.accessToken || '').trim();
          const base = String(message?.payload?.baseUrl || 'https://proapi.115.com').replace(/\/$/, '');
          if (!accessToken) {
            sendResponse({ success: false, message: '缂哄皯 access_token' });
            return true;
          }
          fetch(`${base}/open/offline/get_quota_info`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Accept': 'application/json'
            },
          }).then(async (res) => {
            const raw = await res.json().catch(() => ({} as any));
            const ok = typeof raw.state === 'boolean' ? raw.state : res.ok;
            sendResponse({ success: ok, raw });
          }).catch((err) => {
            sendResponse({ success: false, message: err?.message || '鍚庡彴閰嶉璇锋眰澶辫触' });
          });
          return true; // 寮傛鍝嶅簲
        } catch (e: any) {
          sendResponse({ success: false, message: e?.message || '鍚庡彴閰嶉寮傚父' });
          return true;
        }
      }
      // 鏈尮閰嶄换浣?115 v2 娑堟伅绫诲瀷
      return false;
    });
  }
} catch (e) {
  // 闈欓粯
}


import { getValue, setValue, getSettings, saveSettings } from '../utils/storage';
import { STORAGE_KEYS } from '../utils/config';
import type { LogEntry, LogLevel } from '../types';
import { refreshRecordById } from './sync';
import { quickDiagnose, type DiagnosticResult } from '../utils/webdavDiagnostic';
import { newWorksScheduler } from '../services/newWorks';
import { installConsoleProxy } from '../utils/consoleProxy';
import JSZip from 'jszip';
import { initDB, viewedPut as idbViewedPut, viewedBulkPut as idbViewedBulkPut, viewedCount as idbViewedCount, viewedPage as idbViewedPage, viewedCountByStatus as idbViewedCountByStatus, viewedGetAll as idbViewedGetAll, viewedStats as idbViewedStats, viewedDelete as idbViewedDelete, viewedBulkDelete as idbViewedBulkDelete, viewedQuery as idbViewedQuery, logsAdd as idbLogsAdd, logsBulkAdd as idbLogsBulkAdd, logsQuery as idbLogsQuery, logsClear as idbLogsClear, viewedExportJSON as idbViewedExportJSON, logsExportJSON as idbLogsExportJSON, magnetsUpsertMany as idbMagnetsUpsertMany, magnetsQuery as idbMagnetsQuery, magnetsClearAll as idbMagnetsClearAll, magnetsClearExpired as idbMagnetsClearExpired, actorsPut as idbActorsPut, actorsBulkPut as idbActorsBulkPut, actorsGet as idbActorsGet, actorsDelete as idbActorsDelete, actorsQuery as idbActorsQuery, actorsStats as idbActorsStats, actorsExportJSON as idbActorsExportJSON, newWorksPut as idbNewWorksPut, newWorksBulkPut as idbNewWorksBulkPut, newWorksDelete as idbNewWorksDelete, newWorksGet as idbNewWorksGet, newWorksGetAll as idbNewWorksGetAll, newWorksQuery as idbNewWorksQuery, newWorksStats as idbNewWorksStats, newWorksExportJSON as idbNewWorksExportJSON } from './db';

// console.log('[Background] Service Worker starting up or waking up.');

// 瀹夎缁熶竴鎺у埗鍙颁唬鐞嗭紙浠呮帶鍒舵樉绀哄眰锛屼笉鏀瑰彉鍏ュ簱閫昏緫锛?
installConsoleProxy({
  level: 'DEBUG',
  format: { showTimestamp: true, timestampStyle: 'hms', timeZone: 'Asia/Shanghai', showSource: true, color: true },
  categories: {
    general: { enabled: true, match: () => true, label: 'BG', color: '#2c3e50' },
  },
});

// 灏嗚缃腑鐨勬帶鍒跺彴鏄剧ず閰嶇疆搴旂敤鍒颁唬鐞?
async function applyConsoleSettingsFromStorage() {
  try {
    const settings = await getSettings();
    const logging = settings.logging || {} as any;
    const ctrl: any = (globalThis as any).__JDB_CONSOLE__;
    if (!ctrl) return;
    if (logging.consoleLevel) ctrl.setLevel(logging.consoleLevel);
    if (logging.consoleFormat) {
      ctrl.setFormat({
        showTimestamp: logging.consoleFormat.showTimestamp ?? true,
        showSource: logging.consoleFormat.showSource ?? true,
        color: logging.consoleFormat.color ?? true,
        timeZone: logging.consoleFormat.timeZone || 'Asia/Shanghai',
      });
    }
    if (logging.consoleCategories) {
      const cfg = ctrl.getConfig();
      const allKeys = Object.keys(cfg?.categories || {});
      for (const key of allKeys) {
        const flag = logging.consoleCategories[key];
        if (flag === false) ctrl.disable(key);
        else if (flag === true) ctrl.enable(key);
      }
    }
  } catch (e) {
    console.warn('[ConsoleProxy] Failed to apply settings in BG:', e);
  }
}

applyConsoleSettingsFromStorage();

try {
  chrome.storage.onChanged.addListener((changes, area) => {
    if (area === 'local' && changes[STORAGE_KEYS.SETTINGS]) {
      applyConsoleSettingsFromStorage();
    }
  });
} catch {}

// ---------------- IndexedDB Migration & DB message routing ----------------

async function ensureIDBMigrated(): Promise<void> {
  try {
    await initDB();
    const migrated = await getValue<boolean>(STORAGE_KEYS.IDB_MIGRATED, false);
    if (migrated) return;

    const viewedObj = await getValue<Record<string, any>>(STORAGE_KEYS.VIEWED_RECORDS, {});
    const all = Object.values(viewedObj || {});
    console.info('[DB] Starting initial migration to IndexedDB...', { count: all.length });

    const BATCH = 500;
    for (let i = 0; i < all.length; i += BATCH) {
      const slice = all.slice(i, i + BATCH);
      await idbViewedBulkPut(slice);
      console.info('[DB] Migrated batch', { from: i, to: Math.min(i + BATCH, all.length) });
    }

    await setValue(STORAGE_KEYS.IDB_MIGRATED, true);
    const cnt = await idbViewedCount().catch(() => -1);
    console.info('[DB] Migration finished', { total: all.length, idbCount: cnt });
  } catch (e) {
    console.warn('[DB] Migration failed (will not block extension)', (e as any)?.message);
  }
}

// fire-and-forget on startup/wakeup
ensureIDBMigrated();

// Best-effort: 娓呯悊杩囨湡鐨勭閾剧紦瀛?
try { idbMagnetsClearExpired(Date.now()).catch(() => {}); } catch {}

// 瀹氭椂娓呯悊杩囨湡鐨勭閾剧紦瀛橈紙chrome.alarms锛?
try {
  if (typeof chrome !== 'undefined' && chrome.alarms) {
    // 姣?12 灏忔椂瑙﹀彂涓€娆★紝鍚嶇О鍥哄畾锛岄噸澶嶅垱寤轰細瑕嗙洊
    chrome.alarms.create('MAGNETS_CLEAN_EXPIRED', { periodInMinutes: 720 });
    chrome.alarms.onAlarm.addListener((alarm) => {
      if (alarm?.name === 'MAGNETS_CLEAN_EXPIRED') {
        try { idbMagnetsClearExpired(Date.now()).catch(() => {}); } catch {}
      }
    });
  }
} catch {}

try {
  chrome.runtime.onMessage.addListener((message: any, _sender, sendResponse): boolean | void => {
    if (!message || typeof message !== 'object') return false;
    // DB message routing
    if (message.type === 'DB:VIEWED_PUT') {
      const record = message?.payload?.record;
      idbViewedPut(record).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb put failed' }));
      return true; // async
    }
    if (message.type === 'DB:VIEWED_BULK_PUT') {
      const records = message?.payload?.records || [];
      idbViewedBulkPut(records).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb bulkPut failed' }));
      return true; // async
    }
    if (message.type === 'DB:VIEWED_GET_ALL') {
      idbViewedGetAll().then((records) => sendResponse({ success: true, records }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb getAll failed' }));
      return true; // async
    }
    if (message.type === 'DB:VIEWED_COUNT') {
      const status = message?.payload?.status as any;
      const p = status ? idbViewedCountByStatus(status) : idbViewedCount();
      p.then((total) => sendResponse({ success: true, total }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb count failed' }));
      return true;
    }
    if (message.type === 'DB:VIEWED_PAGE') {
      const payload = message?.payload || {};
      idbViewedPage(payload).then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb page failed' }));
      return true;
    }
    if (message.type === 'DB:VIEWED_QUERY') {
      const payload = message?.payload || {};
      idbViewedQuery(payload).then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb query failed' }));
      return true;
    }
    if (message.type === 'DB:VIEWED_EXPORT') {
      idbViewedExportJSON().then((json) => sendResponse({ success: true, json }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb viewed export failed' }));
      return true;
    }
    if (message.type === 'DB:VIEWED_STATS') {
      idbViewedStats().then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb viewed stats failed' }));
      return true;
    }
    if (message.type === 'DB:VIEWED_DELETE') {
      const id = message?.payload?.id;
      idbViewedDelete(id).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb viewed delete failed' }));
      return true;
    }
    if (message.type === 'DB:VIEWED_BULK_DELETE') {
      const ids = message?.payload?.ids || [];
      idbViewedBulkDelete(ids).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'idb viewed bulk delete failed' }));
      return true;
    }
    if (message.type === 'DB:LOGS_ADD') {
      const entry = message?.payload?.entry;
      idbLogsAdd(entry).then((id) => sendResponse({ success: true, id }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'logs add failed' }));
      return true;
    }
    if (message.type === 'DB:LOGS_BULK') {
      const entries = message?.payload?.entries || [];
      idbLogsBulkAdd(entries).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'logs bulk failed' }));
      return true;
    }
    if (message.type === 'DB:LOGS_QUERY') {
      const payload = message?.payload || {};
      idbLogsQuery(payload).then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'logs query failed' }));
      return true;
    }
    if (message.type === 'DB:LOGS_CLEAR') {
      const beforeMs = message?.payload?.beforeMs;
      idbLogsClear(beforeMs).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'logs clear failed' }));
      return true;
    }
    if (message.type === 'DB:LOGS_EXPORT') {
      idbLogsExportJSON().then((json) => sendResponse({ success: true, json }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'logs export failed' }));
      return true;
    }
    // actors
    if (message.type === 'DB:ACTORS_PUT') {
      const record = message?.payload?.record;
      idbActorsPut(record).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'actors put failed' }));
      return true;
    }
    if (message.type === 'DB:ACTORS_BULK_PUT') {
      const records = message?.payload?.records || [];
      idbActorsBulkPut(records).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'actors bulkPut failed' }));
      return true;
    }
    if (message.type === 'DB:ACTORS_GET') {
      const id = message?.payload?.id;
      idbActorsGet(id).then((record) => sendResponse({ success: true, record }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'actors get failed' }));
      return true;
    }
    if (message.type === 'DB:ACTORS_DELETE') {
      const id = message?.payload?.id;
      idbActorsDelete(id).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'actors delete failed' }));
      return true;
    }
    if (message.type === 'DB:ACTORS_QUERY') {
      const params = message?.payload || {};
      idbActorsQuery(params).then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'actors query failed' }));
      return true;
    }
    if (message.type === 'DB:ACTORS_STATS') {
      idbActorsStats().then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'actors stats failed' }));
      return true;
    }
    if (message.type === 'DB:ACTORS_EXPORT') {
      idbActorsExportJSON().then((json) => sendResponse({ success: true, json }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'actors export failed' }));
      return true;
    }
    // newWorks
    if (message.type === 'DB:NEWWORKS_PUT') {
      const record = message?.payload?.record;
      idbNewWorksPut(record).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks put failed' }));
      return true;
    }
    if (message.type === 'DB:NEWWORKS_BULK_PUT') {
      const records = message?.payload?.records || [];
      idbNewWorksBulkPut(records).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks bulkPut failed' }));
      return true;
    }
    if (message.type === 'DB:NEWWORKS_DELETE') {
      const id = message?.payload?.id;
      idbNewWorksDelete(id).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks delete failed' }));
      return true;
    }
    if (message.type === 'DB:NEWWORKS_GET') {
      const id = message?.payload?.id;
      idbNewWorksGet(id).then((record) => sendResponse({ success: true, record }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks get failed' }));
      return true;
    }
    if (message.type === 'DB:NEWWORKS_GET_ALL') {
      idbNewWorksGetAll().then((records) => sendResponse({ success: true, records }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks getAll failed' }));
      return true;
    }
    if (message.type === 'DB:NEWWORKS_QUERY') {
      const params = message?.payload || {};
      idbNewWorksQuery(params).then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks query failed' }));
      return true;
    }
    if (message.type === 'DB:NEWWORKS_STATS') {
      idbNewWorksStats().then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks stats failed' }));
      return true;
    }
    if (message.type === 'DB:NEWWORKS_EXPORT') {
      idbNewWorksExportJSON().then((json) => sendResponse({ success: true, json }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'newWorks export failed' }));
      return true;
    }
    // magnets
    if (message.type === 'DB:MAGNETS_UPSERT') {
      const records = message?.payload?.records || [];
      idbMagnetsUpsertMany(records).then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'magnets upsert failed' }));
      return true;
    }
    if (message.type === 'DB:MAGNETS_QUERY') {
      const params = message?.payload || {};
      idbMagnetsQuery(params).then((data) => sendResponse({ success: true, ...data }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'magnets query failed' }));
      return true;
    }
    if (message.type === 'DB:MAGNETS_CLEAR') {
      idbMagnetsClearAll().then(() => sendResponse({ success: true }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'magnets clear failed' }));
      return true;
    }
    if (message.type === 'DB:MAGNETS_CLEAR_EXPIRED') {
      const beforeMs = message?.payload?.beforeMs;
      idbMagnetsClearExpired(beforeMs).then((removed) => sendResponse({ success: true, removed }))
        .catch((e) => sendResponse({ success: false, error: e?.message || 'magnets clear expired failed' }));
      return true;
    }
  });
} catch {}

const consoleMap: Record<LogLevel, (message?: any, ...optionalParams: any[]) => void> = {
  INFO: console.info,
  WARN: console.warn,
  ERROR: console.error,
  DEBUG: console.debug,
};

async function log(level: LogLevel, message: string, data?: any) {
  const logFunction = consoleMap[level] || console.log;
  // 鍙湪鏈夋暟鎹椂鎵嶈緭鍑烘暟鎹紝閬垮厤杈撳嚭 undefined
  if (data !== undefined) {
    logFunction(message, data);
  } else {
    logFunction(message);
  }

  try {
        const [logs, settings] = await Promise.all([
            getValue<LogEntry[]>(STORAGE_KEYS.LOGS, []),
            getSettings()
        ]);
        
        const newLogEntry: LogEntry = {
            timestamp: new Date().toISOString(),
            level,
            message,
            data: data, // No longer attempting a deep copy that fails on circular references
        };

        logs.push(newLogEntry);

        // Use the max entries from settings (configured in LoggingSettings)
        const maxEntries = (settings.logging as any)?.maxEntries ?? settings.logging?.maxLogEntries ?? 1500;
        if (logs.length > maxEntries) {
            logs.splice(0, logs.length - maxEntries);
        }

        await setValue(STORAGE_KEYS.LOGS, logs);
        // 寮傛鍙屽啓鍒?IndexedDB 鏃ュ織搴?
        try { idbLogsAdd(newLogEntry).catch(() => {}); } catch {}
    } catch (e) {
        console.error("Failed to write to persistent log:", e);
    }
}

const logger = {
    info: (message: string, data?: any) => log('INFO', message, data),
    warn: (message: string, data?: any) => log('WARN', message, data),
    error: (message: string, data?: any) => log('ERROR', message, data),
    debug: (message: string, data?: any) => log('DEBUG', message, data),
};
    try {
        // 鑾峰彇鎵€鏈夐渶瑕佸悓姝ョ殑鏁版嵁
        const recordsToSync = await getValue(STORAGE_KEYS.VIEWED_RECORDS, {});
        const userProfile = await getValue(STORAGE_KEYS.USER_PROFILE, null);
        const actorRecords = await getValue(STORAGE_KEYS.ACTOR_RECORDS, {});
        const logs = await getValue(STORAGE_KEYS.LOGS, []);
        const importStats = await getValue(STORAGE_KEYS.LAST_IMPORT_STATS, null);

        const dataToExport = {
            version: '2.0', // 娣诲姞鐗堟湰鍙蜂互鏀寔鍚戝悗鍏煎
            timestamp: new Date().toISOString(),
            settings: settings,
            data: recordsToSync,
            userProfile: userProfile,
            actorRecords: actorRecords, // 婕斿憳搴撴暟鎹紙鍖呭惈 blacklisted锛?
            logs: logs, // 鎸佷箙鍖栨棩蹇?
            importStats: importStats, // 瀵煎叆缁熻
            newWorks: { // 鏂板锛氭柊浣滃搧鏁版嵁
                subscriptions: await getValue(STORAGE_KEYS.NEW_WORKS_SUBSCRIPTIONS, {}),
                records: await getValue(STORAGE_KEYS.NEW_WORKS_RECORDS, {}),
                config: await getValue(STORAGE_KEYS.NEW_WORKS_CONFIG, {})
            }
        };
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hour = now.getHours().toString().padStart(2, '0');
        const minute = now.getMinutes().toString().padStart(2, '0');
        const second = now.getSeconds().toString().padStart(2, '0');
        const date = `${year}-${month}-${day}`;
        const filename = `javdb-extension-backup-${date}-${hour}-${minute}-${second}.zip`;
        
        let fileUrl = settings.webdav.url;
        if (!fileUrl.endsWith('/')) fileUrl += '/';
        fileUrl += filename.startsWith('/') ? filename.substring(1) : filename;
        
        // 鐢熸垚ZIP
        const zip = new JSZip();
        zip.file('backup.json', JSON.stringify(dataToExport, null, 2));
        const zipBlob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } });

        await logger.info(`Uploading to ${fileUrl}`);

        const response = await fetch(fileUrl, {
            method: 'PUT',
            headers: {
                'Authorization': 'Basic ' + btoa(`${settings.webdav.username}:${settings.webdav.password}`),
                'Content-Type': 'application/zip'
            },
            body: zipBlob
        });

        if (!response.ok) {
            throw new Error(`Upload failed with status: ${response.status}`);
        }

        // Update last sync time and cleanup old backups according to retention
        const updatedSettings = await getSettings();
        updatedSettings.webdav.lastSync = new Date().toISOString();
        await saveSettings(updatedSettings);
        await logger.info('WebDAV upload successful, updated last sync time.');

        try {
            const retentionDays = Number(updatedSettings.webdav.retentionDays ?? 7);
            if (!isNaN(retentionDays) && retentionDays > 0) {
                await cleanupOldBackups(retentionDays);
            }
        } catch (e) {
            await logger.warn('Failed to cleanup old WebDAV backups', { error: (e as Error).message });
        }

        return { success: true };
    } catch (error: any) {
        await logger.error('WebDAV upload failed.', { error: error.message });
        return { success: false, error: error.message };
    }
}
    try {
        let finalUrl: string;
        const webdavBaseUrl = settings.webdav.url;

        if (filename.startsWith('http://') || filename.startsWith('https://')) {
            finalUrl = filename;
        } else if (filename.startsWith('/')) {
            const origin = new URL(webdavBaseUrl).origin;
            finalUrl = new URL(filename, origin).href;
        } else {
            let base = webdavBaseUrl;
            if (!base.endsWith('/')) base += '/';
            finalUrl = new URL(filename, base).href;
        }

        await logger.info(`Attempting to restore from WebDAV URL: ${finalUrl}`);
        
        const response = await fetch(finalUrl, {
            method: 'GET',
            headers: {
                'Authorization': 'Basic ' + btoa(`${settings.webdav.username}:${settings.webdav.password}`)
            }
        });

        if (!response.ok) {
            throw new Error(`Download failed with status: ${response.status}`);
        }

        const isZip = /\.zip$/i.test(finalUrl);
        let importData: any;
        if (isZip) {
            const arrayBuf = await response.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuf);
            // 浼樺厛灏濊瘯 backup.json
            const jsonFile = zip.file('backup.json') || zip.file(/\.json$/i)[0];
            if (!jsonFile) {
                throw new Error('ZIP 涓湭鎵惧埌 JSON 澶囦唤鏂囦欢');
            }
            const jsonText = await jsonFile.async('text');
            importData = JSON.parse(jsonText);
        } else {
            const fileContents = await response.text();
            importData = JSON.parse(fileContents);
        }

        await logger.info('Parsed backup data', {
            hasSettings: !!importData.settings,
            hasData: !!importData.data,
            hasUserProfile: !!importData.userProfile,
            hasActorRecords: !!importData.actorRecords,
            hasLogs: !!importData.logs,
            hasImportStats: !!importData.importStats,
            hasNewWorks: !!importData.newWorks,
            version: importData.version || '1.0',
            preview: options.preview
        });

        // 濡傛灉鏄瑙堟ā寮忥紝杩斿洖瀹屾暣鏁版嵁鐢ㄤ簬宸紓鍒嗘瀽
        if (options.preview) {
            return {
                success: true,
                data: {
                    version: importData.version || '1.0',
                    timestamp: importData.timestamp,
                    settings: importData.settings || null,
                    data: importData.data || importData.viewed || null, // 鍏煎鏃ф牸寮?
                    viewed: importData.viewed || null, // 鍚戝悗鍏煎
                    userProfile: importData.userProfile || null,
                    actorRecords: importData.actorRecords || null,
                    logs: importData.logs || null,
                    importStats: importData.importStats || null,
                    newWorks: importData.newWorks || null
                }
            };
        }

        // 鎭㈠鎵╁睍璁剧疆
        if (importData.settings && options.restoreSettings) {
            await saveSettings(importData.settings);
            await logger.info('Restored settings');
        }

        // 鎭㈠瑙嗛璁板綍
        if (importData.data && options.restoreRecords) {
            await setValue(STORAGE_KEYS.VIEWED_RECORDS, importData.data);
            await logger.info('Restored video records');
        } else if (options.restoreRecords) {
            // 鍚戝悗鍏煎锛氭棫鐗堟湰鐨勫浠芥牸寮?
            await setValue(STORAGE_KEYS.VIEWED_RECORDS, importData);
            await logger.info('Restored video records (legacy format)');
        }

        // 鎭㈠鐢ㄦ埛閰嶇疆
        if (importData.userProfile && options.restoreUserProfile) {
            await setValue(STORAGE_KEYS.USER_PROFILE, importData.userProfile);
            await logger.info('Restored user profile');
        }

        // 鎭㈠婕斿憳搴撴暟鎹紙鍖呭惈 blacklisted锛?
        if (importData.actorRecords && options.restoreActorRecords) {
            await setValue(STORAGE_KEYS.ACTOR_RECORDS, importData.actorRecords);
            await logger.info('Restored actor records', {
                actorCount: Object.keys(importData.actorRecords).length
            });
        }

        // 鎭㈠鏃ュ織锛堝彲閫夛級
        if (importData.logs && options.restoreLogs) {
            await setValue(STORAGE_KEYS.LOGS, importData.logs);
            await logger.info('Restored logs', {
                logCount: Array.isArray(importData.logs) ? importData.logs.length : 0
            });
        }

        // 鎭㈠瀵煎叆缁熻锛堝彲閫夛級
        if (importData.importStats && options.restoreImportStats) {
            await setValue(STORAGE_KEYS.LAST_IMPORT_STATS, importData.importStats);
            await logger.info('Restored import statistics');
        }

        // 鏂板锛氭仮澶嶆柊浣滃搧鏁版嵁
        if (importData.newWorks) {
            if (importData.newWorks.subscriptions) {
                await setValue(STORAGE_KEYS.NEW_WORKS_SUBSCRIPTIONS, importData.newWorks.subscriptions);
            }
            if (importData.newWorks.records) {
                await setValue(STORAGE_KEYS.NEW_WORKS_RECORDS, importData.newWorks.records);
            }
            if (importData.newWorks.config) {
                await setValue(STORAGE_KEYS.NEW_WORKS_CONFIG, importData.newWorks.config);
            }
            await logger.info('Restored new works data');
        }

        return { success: true };
    } catch (error: any) {
        await logger.error('Failed to restore from WebDAV.', { error: error.message, filename });
        return { success: false, error: error.message };
    }
}
    try {
        let url = settings.webdav.url;
        if (!url.endsWith('/')) url += '/';

        await logger.info(`Sending PROPFIND request to: ${url}`);

        // 澧炲己鐨勮姹傚ご锛屾敮鎸佹洿澶歐ebDAV鏈嶅姟鍣?
        const headers: Record<string, string> = {
            'Authorization': 'Basic ' + btoa(`${settings.webdav.username}:${settings.webdav.password}`),
            'Depth': '1',
            'Content-Type': 'application/xml; charset=utf-8',
            'User-Agent': 'JavDB-Extension/1.0'
        };

        // 瀵逛簬鏌愪簺鏈嶅姟鍣紝鍙兘闇€瑕佸彂閫乆ML body
        const xmlBody = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:">
    <D:allprop/>
</D:propfind>`;

        const response = await fetch(url, {
            method: 'PROPFIND',
            headers: headers,
            body: xmlBody
        });

        await logger.info(`WebDAV response status: ${response.status} ${response.statusText}`);
        const __headersObj: Record<string, string> = {};
        try {
            response.headers.forEach((value, key) => { __headersObj[key] = value; });
        } catch {}
        await logger.debug(`WebDAV response headers:`, __headersObj);

        if (!response.ok) {
            // 鎻愪緵鏇磋缁嗙殑閿欒淇℃伅
            let errorDetail = `HTTP ${response.status}: ${response.statusText}`;
            if (response.status === 401) {
                errorDetail += ' - 璁よ瘉澶辫触锛岃妫€鏌ョ敤鎴峰悕鍜屽瘑鐮?;
            } else if (response.status === 403) {
                errorDetail += ' - 璁块棶琚嫆缁濓紝璇锋鏌ユ潈闄愯缃?;
            } else if (response.status === 404) {
                errorDetail += ' - 璺緞涓嶅瓨鍦紝璇锋鏌ebDAV URL';
            } else if (response.status === 405) {
                errorDetail += ' - 鏈嶅姟鍣ㄤ笉鏀寔PROPFIND鏂规硶';
            } else if (response.status >= 500) {
                errorDetail += ' - 鏈嶅姟鍣ㄥ唴閮ㄩ敊璇?;
            }

            throw new Error(errorDetail);
        }

        const text = await response.text();
        await logger.debug("Received WebDAV PROPFIND response:", {
            responseLength: text.length,
            responsePreview: text.substring(0, 500) + (text.length > 500 ? '...' : '')
        });

        if (!text || text.trim().length === 0) {
            throw new Error('鏈嶅姟鍣ㄨ繑鍥炵┖鍝嶅簲');
        }

        const files = parseWebDAVResponse(text);
        await logger.info(`Successfully parsed ${files.length} files from WebDAV response`);
        await logger.debug("Parsed WebDAV files:", { files });

        if (files.length === 0) {
            await logger.warn('No backup files found in WebDAV response. This might be normal if no backups exist yet.');
        }

        return { success: true, files: files };
    } catch (error: any) {
        await logger.error('Failed to list WebDAV files.', {
            error: error.message,
            url: settings.webdav.url,
            username: settings.webdav.username ? '[CONFIGURED]' : '[NOT SET]'
        });
        return { success: false, error: error.message };
    }
}

/**
 * 娓呯悊瓒呰繃淇濈暀澶╂暟鐨勫浠芥枃浠?
 */
    try {
        const result = await listFiles();
        if (!result.success || !result.files || result.files.length === 0) {
            return;
        }

        const files = result.files
            .filter(f => f.name.includes('javdb-extension-backup-') && (f.name.endsWith('.json') || f.name.endsWith('.zip')))
            // 鎸夊悕绉颁腑鐨勬椂闂存帓搴忥紝杈冩柊鐨勫湪鍓嶏紙鍚嶇О鏍煎紡锛歫avdb-extension-backup-YYYY-MM-DD-HH-MM-SS.json 鎴?-YYYY-MM-DD.json锛?
            .sort((a, b) => a.name > b.name ? -1 : 1);

        const nowMs = Date.now();
        const maxAgeMs = retentionDays * 24 * 60 * 60 * 1000;

        for (const file of files) {
            // 濡傛灉鏈嶅姟鍣ㄨ繑鍥炰簡 lastModified锛屼紭鍏堜娇鐢ㄥ畠
            let fileTime = 0;
            if (file.lastModified && file.lastModified !== 'N/A') {
                const parsed = Date.parse(file.lastModified);
                if (!isNaN(parsed)) fileTime = parsed;
            }

            // 濡傛灉鏃犳硶浠?lastModified 寰楀埌鏃堕棿锛屽垯浠庢枃浠跺悕瑙ｆ瀽
            if (!fileTime) {
                // 鏀寔涓ょ鍛藉悕锛歒YYY-MM-DD-HH-MM-SS 鍜?YYYY-MM-DD
                const match = file.name.match(/javdb-extension-backup-(\d{4}-\d{2}-\d{2})(?:-(\d{2})-(\d{2})-(\d{2}))?\.(json|zip)$/);
                if (match) {
                    const datePart = match[1];
                    const h = match[2] || '00';
                    const m = match[3] || '00';
                    const s = match[4] || '00';
                    const iso = `${datePart}T${h}:${m}:${s}Z`;
                    const parsed = Date.parse(iso);
                    if (!isNaN(parsed)) fileTime = parsed;
                }
            }

            if (!fileTime) {
                continue;
            }

            const ageMs = nowMs - fileTime;
            if (ageMs > maxAgeMs) {
                try {
                    // 鏋勯€犲畬鏁?URL 杩涜鍒犻櫎
                    let base = settings.webdav.url;
                    if (!base.endsWith('/')) base += '/';
                    const fileUrl = new URL(file.path.startsWith('/') ? file.path.substring(1) : file.path, base).href;
                    await fetch(fileUrl, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': 'Basic ' + btoa(`${settings.webdav.username}:${settings.webdav.password}`),
                            'User-Agent': 'JavDB-Extension/1.0'
                        }
                    });
                    await logger.info('Deleted expired WebDAV backup', { name: file.name, url: fileUrl });
                } catch (e) {
                    await logger.warn('Failed to delete expired WebDAV backup', { name: file.name, error: (e as Error).message });
                }
            }
        }
    } catch (e) {
        await logger.warn('cleanupOldBackups encountered an error', { error: (e as Error).message });
    }
}

function parseWebDAVResponse(xmlString: string): WebDAVFile[] {
    const files: WebDAVFile[] = [];

    // 鏇村己澶х殑XML鍛藉悕绌洪棿澶勭悊锛屾敮鎸佸绉峎ebDAV鏈嶅姟鍣?
    let simplifiedXml = xmlString;

    // 绉婚櫎鎵€鏈塜ML鍛藉悕绌洪棿鍓嶇紑锛屾敮鎸佹洿澶氭湇鍔″櫒鏍煎紡
    simplifiedXml = simplifiedXml.replace(/<(\/)?\w+:/g, '<$1');
    simplifiedXml = simplifiedXml.replace(/\s+xmlns[^=]*="[^"]*"/g, '');

    // 澶氱response鏍囩鏍煎紡鏀寔
    const responsePatterns = [
        /<response>(.*?)<\/response>/gs,
        /<multistatus[^>]*>(.*?)<\/multistatus>/gs,
        /<propstat[^>]*>(.*?)<\/propstat>/gs
    ];

    // 澶氱href鏍囩鏍煎紡鏀寔
    const hrefPatterns = [
        /<href[^>]*>(.*?)<\/href>/i,
        /<displayname[^>]*>(.*?)<\/displayname>/i,
        /<name[^>]*>(.*?)<\/name>/i
    ];

    // 澶氱鏃堕棿鏍煎紡鏀寔
    const timePatterns = [
        /<getlastmodified[^>]*>(.*?)<\/getlastmodified>/i,
        /<lastmodified[^>]*>(.*?)<\/lastmodified>/i,
        /<modificationtime[^>]*>(.*?)<\/modificationtime>/i,
        /<creationdate[^>]*>(.*?)<\/creationdate>/i
    ];

    // 澶氱澶у皬鏍煎紡鏀寔
    const sizePatterns = [
        /<getcontentlength[^>]*>(.*?)<\/getcontentlength>/i,
        /<contentlength[^>]*>(.*?)<\/contentlength>/i,
        /<size[^>]*>(.*?)<\/size>/i
    ];

    // 澶氱鐩綍妫€娴嬫牸寮忔敮鎸?
    const collectionPatterns = [
        /<resourcetype[^>]*>.*?<collection[^>]*\/>.*?<\/resourcetype>/i,
        /<resourcetype[^>]*>.*?<collection[^>]*>.*?<\/collection>.*?<\/resourcetype>/i,
        /<getcontenttype[^>]*>.*?directory.*?<\/getcontenttype>/i,
        /<iscollection[^>]*>true<\/iscollection>/i
    ];

    // 灏濊瘯涓嶅悓鐨剅esponse妯″紡
    for (const responsePattern of responsePatterns) {
        let match;
        responsePattern.lastIndex = 0; // 閲嶇疆姝ｅ垯琛ㄨ揪寮忕姸鎬?

        while ((match = responsePattern.exec(simplifiedXml)) !== null) {
            const responseXml = match[1];

            // 灏濊瘯鎻愬彇href/鏂囦欢鍚?
            let href = '';
            let displayName = '';

            for (const hrefPattern of hrefPatterns) {
                const hrefMatch = responseXml.match(hrefPattern);
                if (hrefMatch && hrefMatch[1]) {
                    href = hrefMatch[1].trim();
                    // 浠巋ref涓彁鍙栨枃浠跺悕
                    if (href.includes('/')) {
                        displayName = decodeURIComponent(href.split('/').filter(Boolean).pop() || '');
                    } else {
                        displayName = decodeURIComponent(href);
                    }
                    break;
                }
            }

            if (!href || !displayName) continue;

            // 妫€鏌ユ槸鍚︿负鐩綍
            let isDirectory = false;
            for (const collectionPattern of collectionPatterns) {
                if (collectionPattern.test(responseXml)) {
                    isDirectory = true;
                    break;
                }
            }

            // 濡傛灉鏄洰褰曟垨鑰卙ref浠?缁撳熬锛岃烦杩?
            if (isDirectory || href.endsWith('/')) {
                continue;
            }

            // 鍙鐞嗗寘鍚浠芥枃浠跺悕鐨勬枃浠?
            if (displayName.includes('javdb-extension-backup')) {
                // 灏濊瘯鎻愬彇鏈€鍚庝慨鏀规椂闂?
                let lastModified = 'N/A';
                for (const timePattern of timePatterns) {
                    const timeMatch = responseXml.match(timePattern);
                    if (timeMatch && timeMatch[1]) {
                        try {
                            lastModified = new Date(timeMatch[1]).toLocaleString();
                            break;
                        } catch (e) {
                            // 濡傛灉鏃ユ湡瑙ｆ瀽澶辫触锛岀户缁皾璇曞叾浠栨牸寮?
                            continue;
                        }
                    }
                }

                // 灏濊瘯鎻愬彇鏂囦欢澶у皬
                let size: number | undefined;
                for (const sizePattern of sizePatterns) {
                    const sizeMatch = responseXml.match(sizePattern);
                    if (sizeMatch && sizeMatch[1]) {
                        const parsedSize = parseInt(sizeMatch[1], 10);
                        if (!isNaN(parsedSize)) {
                            size = parsedSize;
                            break;
                        }
                    }
                }

                files.push({
                    name: displayName,
                    path: href,
                    lastModified: lastModified,
                    isDirectory: false,
                    size: size,
                });
            }
        }

        // 濡傛灉鎵惧埌浜嗘枃浠讹紝灏变笉闇€瑕佸皾璇曞叾浠栨ā寮忎簡
        if (files.length > 0) {
            break;
        }
    }

    return files;
}
    try {
        let url = settings.webdav.url;
        if (!url.endsWith('/')) url += '/';

        await logger.info(`Testing connection to: ${url}`);

        // 澧炲己鐨勮姹傚ご
        const headers: Record<string, string> = {
            'Authorization': 'Basic ' + btoa(`${settings.webdav.username}:${settings.webdav.password}`),
            'Depth': '0',
            'Content-Type': 'application/xml; charset=utf-8',
            'User-Agent': 'JavDB-Extension/1.0'
        };

        // 绠€鍗曠殑XML body鐢ㄤ簬娴嬭瘯
        const xmlBody = `<?xml version="1.0" encoding="utf-8"?>
<D:propfind xmlns:D="DAV:">
    <D:prop>
        <D:resourcetype/>
        <D:getcontentlength/>
        <D:getlastmodified/>
    </D:prop>
</D:propfind>`;

        const response = await fetch(url, {
            method: 'PROPFIND',
            headers: headers,
            body: xmlBody
        });

        await logger.info(`Test response: ${response.status} ${response.statusText}`);

        if (response.ok) {
            // 灏濊瘯璇诲彇鍝嶅簲鍐呭浠ラ獙璇佹湇鍔″櫒鏄惁姝ｇ‘鏀寔WebDAV
            const responseText = await response.text();
            await logger.debug('Test response content:', {
                length: responseText.length,
                preview: responseText.substring(0, 200)
            });

            // 妫€鏌ュ搷搴旀槸鍚﹀寘鍚玏ebDAV鐩稿叧鍐呭
            if (responseText.includes('<?xml') || responseText.includes('<multistatus') || responseText.includes('<response')) {
                await logger.info('WebDAV connection test successful - server supports WebDAV protocol');
                return { success: true };
            } else {
                await logger.warn('Server responded but may not support WebDAV properly');
                return {
                    success: false,
                    error: '鏈嶅姟鍣ㄥ搷搴旀垚鍔熶絾鍙兘涓嶆敮鎸乄ebDAV鍗忚锛岃妫€鏌RL鏄惁姝ｇ‘'
                };
            }
        } else {
            let errorMsg = `Connection test failed with status: ${response.status} ${response.statusText}`;

            // 鎻愪緵閽堝鎬х殑閿欒鎻愮ず
            if (response.status === 401) {
                errorMsg += ' - 璁よ瘉澶辫触锛岃妫€鏌ョ敤鎴峰悕鍜屽瘑鐮?;
            } else if (response.status === 403) {
                errorMsg += ' - 璁块棶琚嫆缁濓紝璇锋鏌ヨ处鎴锋潈闄?;
            } else if (response.status === 404) {
                errorMsg += ' - WebDAV璺緞涓嶅瓨鍦紝璇锋鏌RL';
            } else if (response.status === 405) {
                errorMsg += ' - 鏈嶅姟鍣ㄤ笉鏀寔WebDAV';
            }

            await logger.warn(errorMsg);
            return { success: false, error: errorMsg };
        }
    } catch (error: any) {
        let errorMsg = error.message;

        // 缃戠粶閿欒鐨勫弸濂芥彁绀?
        if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
            errorMsg = '缃戠粶杩炴帴澶辫触锛岃妫€鏌ョ綉缁滆繛鎺ュ拰鏈嶅姟鍣ㄥ湴鍧€';
        } else if (errorMsg.includes('CORS')) {
            errorMsg = 'CORS閿欒锛屽彲鑳芥槸鏈嶅姟鍣ㄩ厤缃棶棰?;
        }

        await logger.error('WebDAV connection test failed.', {
            error: errorMsg,
            originalError: error.message,
            url: settings.webdav.url
        });
        return { success: false, error: errorMsg };
    }
}
    try {
        const diagnostic = await quickDiagnose({
            url: settings.webdav.url,
            username: settings.webdav.username,
            password: settings.webdav.password
        });

        await logger.info('WebDAV diagnostic completed', diagnostic);

        return {
            success: true,
            diagnostic: diagnostic
        };
    } catch (error: any) {
        await logger.error('WebDAV diagnostic failed.', { error: error.message });
        return { success: false, error: error.message };
    }
}

chrome.runtime.onMessage.addListener((message, _sender, sendResponse): boolean | void => {

    // console.log(`[Background] onMessage listener triggered. Received message:`, message);
    // console.log(`[Background] Message type: ${message.type}`);

    try {
        switch (message.type) {
            // ... (rest of the code remains the same)
            case 'ping':
            case 'ping-background':
                // console.log('[Background] Ping received, sending pong.');
                sendResponse({ success: true, message: 'pong' });
                return true;
            case 'get-logs':
                // console.log('[Background] Processing get-logs request.');
                getValue(STORAGE_KEYS.LOGS, [])
                    .then(logs => {
                        // console.log(`[Background] Retrieved ${logs.length} log entries.`);
                        sendResponse({ success: true, logs });
                    })
                    .catch(error => {
                        console.error('[Background] Failed to get logs:', error);
                        sendResponse({ success: false, error: error.message });
                    });
                return true;
            case 'log-message':
                // console.log('[Background] Processing log-message request.');
                const { payload } = message;
                if (payload && payload.level && payload.message) {
                    log(payload.level, payload.message, payload.data)
                        .then(() => {
                            sendResponse({ success: true });
                        })
                        .catch(error => {
                            console.error('[Background] Failed to log message:', error);
                            sendResponse({ success: false, error: error.message });
                        });
                } else {
                    sendResponse({ success: false, error: 'Invalid log message payload' });
                }
                return true;
            case 'clear-all-records':
                console.log('[Background] Processing clear-all-records request.');
                setValue(STORAGE_KEYS.VIEWED_RECORDS, {})
                    .then(() => {
                        console.log('[Background] All records cleared successfully.');
                        sendResponse({ success: true });
                    })
                    .catch(error => {
                        console.error('[Background] Failed to clear all records:', error);
                        sendResponse({ success: false, error: error.message });
                    });
                return true;
            case 'refresh-record':
                const { videoId } = message;
                console.log(`[Background] Processing refresh-record for videoId: ${videoId}`);

                if (!videoId) {
                    console.error('[Background] Refresh request missing videoId. Sending error response.');
                    sendResponse({ success: false, error: 'No videoId provided.' });
                    return true;
                }

                console.log(`[Background] About to call refreshRecordById for: ${videoId}`);

                refreshRecordById(videoId)
                    .then(updatedRecord => {
                        console.log(`[Background] refreshRecordById successful for ${videoId}. Sending success response.`);
                        console.log(`[Background] Updated record:`, updatedRecord);
                        sendResponse({ success: true, record: updatedRecord });
                    })
                    .catch(error => {
                        console.error(`[Background] refreshRecordById failed for ${videoId}:`, error);
                        console.error(`[Background] Error stack:`, error.stack);
                        sendResponse({ success: false, error: error.message });
                    });

                // Return true to indicate that the response will be sent asynchronously.
                return true;
            case 'fetch-user-profile':
                console.log('[Background] Processing fetch-user-profile request.');
                fetchUserProfileFromJavDB()
                    .then((profile: any) => {
                        console.log('[Background] User profile fetch result:', profile);
                        sendResponse({ success: true, profile });
                    })
                    .catch((error: any) => {
                        console.error('[Background] Failed to fetch user profile:', error);
                        sendResponse({ success: false, error: error.message });
                    });
                return true;
            case 'setup-alarms':
                console.log('[Background] Processing setup-alarms request.');
                setupAlarms()
                    .then(() => {
                        console.log('[Background] Alarms setup completed.');
                        sendResponse({ success: true });
                    })
                    .catch((error: any) => {
                        console.error('[Background] Failed to setup alarms:', error);
                        sendResponse({ success: false, error: error.message });
                    });
                return true;
            case 'new-works-manual-check':
                console.log('[Background] Processing new-works-manual-check request.');
                newWorksScheduler.triggerManualCheck()
                    .then(result => {
                        console.log('[Background] Manual new works check completed:', result);
                        sendResponse({ success: true, result });
                    })
                    .catch(error => {
                        console.error('[Background] Failed to perform manual new works check:', error);
                        sendResponse({ success: false, error: error.message });
                    });
                return true;
            case 'new-works-scheduler-restart':
                console.log('[Background] Processing new-works-scheduler-restart request.');
                newWorksScheduler.restart()
                    .then(() => {
                        console.log('[Background] New works scheduler restarted.');
                        sendResponse({ success: true });
                    })
                    .catch(error => {
                        console.error('[Background] Failed to restart new works scheduler:', error);
                        sendResponse({ success: false, error: error.message });
                    });
                return true;
            case 'new-works-scheduler-status':
                console.log('[Background] Processing new-works-scheduler-status request.');
                try {
                    const status = newWorksScheduler.getStatus();
                    sendResponse({ success: true, status });
                } catch (error: any) {
                    console.error('[Background] Failed to get new works scheduler status:', error);
                    sendResponse({ success: false, error: error.message });
                }
                return true;
            case 'fetch-external-data':
                console.log('[Background] Processing fetch-external-data request.');
                handleExternalDataFetch(message, sendResponse);
                return true;
            case 'DRIVE115_PUSH':
                console.log('[Background] Processing DRIVE115_PUSH request.');
                handleDrive115Push(message, sendResponse);
                return true;
            case 'DRIVE115_VERIFY':
                console.log('[Background] Processing DRIVE115_VERIFY request.');
                handleDrive115Verify(message, sendResponse);
                return true;
            case 'DRIVE115_HEARTBEAT':
                console.log('[Background] Received heartbeat from 115 content script');
                sendResponse({ type: 'DRIVE115_HEARTBEAT_RESPONSE', success: true });
                return true;
            case 'UPDATE_WATCHED_STATUS':
                console.log('[Background] Processing UPDATE_WATCHED_STATUS request.');
                handleUpdateWatchedStatus(message, sendResponse);
                return true; // 淇濇寔娑堟伅閫氶亾寮€鏀?
            case 'OPEN_TAB_BACKGROUND':
                console.log('[Background] Processing OPEN_TAB_BACKGROUND request.');
                handleOpenTabBackground(message, sendResponse);
                return true;
            case 'CHECK_VIDEO_URL':
                console.log('[Background] Processing CHECK_VIDEO_URL request.');
                handleCheckVideoUrl(message, sendResponse);
                return true;
            case 'FETCH_JAVSPYL_PREVIEW':
                console.log('[Background] Processing FETCH_JAVSPYL_PREVIEW request.');
                handleFetchJavSpylPreview(message, sendResponse);
                return true;
            case 'FETCH_AVPREVIEW_PREVIEW':
                console.log('[Background] Processing FETCH_AVPREVIEW_PREVIEW request.');
                handleFetchAVPreviewPreview(message, sendResponse);
                return true;
            case 'FETCH_JAVDB_PREVIEW':
                console.log('[Background] Processing FETCH_JAVDB_PREVIEW request.');
                handleFetchJavDBPreview(message, sendResponse);
                return true;
            case 'drive115.refresh_token_v2':
                // 鍏滃簳澶勭悊锛氶伩鍏嶉儴鍒嗙幆澧冩湭娉ㄥ唽 v2 浠ｇ悊鐩戝惉鍣ㄦ椂鍑虹幇鏈煡娑堟伅绫诲瀷
                try {
                    const rt = String(message?.payload?.refreshToken || '').trim();
                    const refreshBase = 'https://passportapi.115.com';
                    if (!rt) {
                        sendResponse({ success: false, message: '缂哄皯 refresh_token' });
                        return true;
                    }
                    const fd = new URLSearchParams();
                    fd.set('refresh_token', rt);
                    fetch(`${refreshBase}/open/refreshToken`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json' },
                        body: fd.toString(),
                    })
                        .then(async (res) => {
                            const raw = await res.json().catch(() => ({} as any));
                            const ok = typeof raw.state === 'boolean' ? raw.state : res.ok;
                            sendResponse({ success: ok, raw });
                        })
                        .catch((err) => {
                            sendResponse({ success: false, message: err?.message || '鍚庡彴鍒锋柊璇锋眰澶辫触' });
                        });
                    return true; // 寮傛鍝嶅簲
                } catch (e: any) {
                    sendResponse({ success: false, message: e?.message || '鍚庡彴鍒锋柊寮傚父' });
                    return true;
                }
            default:
                console.warn(`[Background] Received unknown message type: ${message.type}. Ignoring.`);
                return false;
        }
    } catch (error: any) {
        console.error(`[Background] Error in message handler:`, error);
        sendResponse({ success: false, error: 'Internal error in background script' });
        return true;
    }
// ... (鍏朵粬浠ｇ爜淇濇寔涓嶅彉)
});

// ===== Helper functions (妯″潡浣滅敤鍩? =====

// 浠?JavDB 椤甸潰鎻愬彇棰勮瑙嗛
async function handleFetchJavDBPreview(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const { url } = message || {};
        if (!url) {
            sendResponse({ success: false, error: 'No URL provided' });
            return;
        }
        const res = await fetch(url);
        if (!res.ok) {
            sendResponse({ success: false, error: `Failed to fetch JavDB page: ${res.status}` });
            return;
        }
        const html = await res.text();
        const m = html.match(/id=\"preview-video\"[\s\S]*?<source[^>]*src=[\"']([^\"']+)[\"']/i);
        if (m && m[1]) {
            sendResponse({ success: true, videoUrl: m[1] });
        } else {
            sendResponse({ success: false, error: 'Preview video not found' });
        }
    } catch (error: any) {
        console.error('[Background] Failed to fetch JavDB preview:', error);
        sendResponse({ success: false, error: error.message });
    }
}

// 115 璺ㄩ〉鎺ㄩ€?
async function handleDrive115Push(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const tabs = await chrome.tabs.query({ url: '*://115.com/*' });
        if (!tabs.length) {
            sendResponse({ type: 'DRIVE115_PUSH_RESPONSE', requestId: message?.requestId, success: false, error: '鏈壘鍒?115.com 鏍囩椤? });
            return;
        }
        chrome.tabs.sendMessage(tabs[0].id!, message, (response) => {
            if (chrome.runtime.lastError) {
                sendResponse({ type: 'DRIVE115_PUSH_RESPONSE', requestId: message?.requestId, success: false, error: chrome.runtime.lastError.message });
            } else {
                sendResponse(response);
            }
        });
    } catch (error: any) {
        console.error('[Background] Failed to handle DRIVE115_PUSH:', error);
        sendResponse({ type: 'DRIVE115_PUSH_RESPONSE', requestId: message?.requestId, success: false, error: error.message });
    }
}

// 115 鐜楠岃瘉
async function handleDrive115Verify(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const tabs = await chrome.tabs.query({ url: '*://115.com/*' });
        if (!tabs.length) {
            sendResponse({ success: false, error: '鏈壘鍒?115.com 鏍囩椤? });
            return;
        }
        chrome.tabs.sendMessage(tabs[0].id!, message, (response) => {
            if (chrome.runtime.lastError) {
                sendResponse({ success: false, error: chrome.runtime.lastError.message });
            } else {
                sendResponse(response ?? { success: true });
            }
        });
    } catch (error: any) {
        console.error('[Background] Failed to handle DRIVE115_VERIFY:', error);
        sendResponse({ success: false, error: error.message });
    }
}

// 鏇存柊宸茬湅鐘舵€?
async function handleUpdateWatchedStatus(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const videoId = message?.videoId;
        if (!videoId) {
            sendResponse({ success: false, error: 'No videoId provided' });
            return;
        }
        const record: any = {
            id: videoId,
            title: '',
            status: 'viewed',
            tags: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
        };
        await idbViewedPut(record);
        sendResponse({ success: true, record });
    } catch (error: any) {
        console.error('[Background] Failed to update watched status:', error);
        sendResponse({ success: false, error: error.message });
    }
}

// 澶栭儴鎷夊彇鏁版嵁锛堢畝鍖栫増锛?
async function handleExternalDataFetch(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const url = message?.url;
        const options = message?.options || {};
        if (!url) {
            sendResponse({ success: false, error: 'No URL provided' });
            return;
        }
        const response = await fetch(url, options as RequestInit);
        const responseType = options.responseType || 'text';
        let data: any;
        if (responseType === 'json') data = await response.json().catch(() => null);
        else if (responseType === 'blob') data = await response.blob();
        else data = await response.text();
        const headersObj: Record<string, string> = {};
        try { response.headers.forEach((v, k) => { headersObj[k] = v; }); } catch {}
        sendResponse({ success: true, data, status: response.status, headers: headersObj });
    } catch (error: any) {
        console.error('[Background] Failed to fetch external data:', error);
        sendResponse({ success: false, error: error.message });
    }
}

// 鎷夊彇鐢ㄦ埛璧勬枡锛堝崰浣嶅疄鐜帮級
async function fetchUserProfileFromJavDB(): Promise<any> {
    try {
        const profile = await getValue(STORAGE_KEYS.USER_PROFILE, null);
        return profile || { isLoggedIn: false };
    } catch {
        return { isLoggedIn: false };
    }
}

// 闂归挓涓庤嚜鍔ㄥ悓姝ワ紙鍗犱綅瀹炵幇锛?
async function setupAlarms(): Promise<void> {
    try { /* no-op */ } catch {}
}
async function triggerAutoSync(): Promise<void> {
    try { /* no-op */ } catch {}
}

async function handleOpenTabBackground(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const { url } = message;
        if (!url) {
            sendResponse({ success: false, error: 'No URL provided' });
            return;
        }

        // 鍦ㄥ悗鍙版墦寮€鏂版爣绛鹃〉
        const tab = await chrome.tabs.create({
            url: url,
            active: false // 鍚庡彴鎵撳紑
        });

        console.log(`[Background] Opened background tab: ${url}`);
        sendResponse({ success: true, tabId: tab.id });
    } catch (error: any) {
        console.error('[Background] Failed to open background tab:', error);
        sendResponse({ success: false, error: error.message });
    }
}

// 妫€鏌ヨ棰慤RL鏄惁鍙敤
async function handleCheckVideoUrl(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const { url } = message;
        if (!url) {
            sendResponse({ success: false, error: 'No URL provided' });
            return;
        }

        console.log(`[Background] Checking video URL: ${url}`);

        // 灏濊瘯澶氱鏂规硶楠岃瘉URL
        let available = false;

        // 鏂规硶1: 灏濊瘯鍙鐨?HEAD 璇锋眰锛堜笉浣跨敤 no-cors锛屼究浜庤鍙栫姸鎬佺爜锛?
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5绉掕秴鏃?

            const response = await fetch(url, {
                method: 'HEAD',
                signal: controller.signal
            });

            clearTimeout(timeoutId);
            available = response.ok; // 蹇呴』涓哄彲璇讳笖 OK
            console.log(`[Background] HEAD check for ${url}: available=${available}, status=${response.status}`);

            if (available) {
                sendResponse({ success: true, available: true });
                return;
            }
        } catch (headError: any) {
            console.log(`[Background] HEAD request failed for ${url}:`, headError?.message);
        }

        // 鏂规硶2: 灏濊瘯甯?Range 鐨?GET锛堣鍙栫姸鎬佺爜锛屽厑璁?200/206锛?
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Range': 'bytes=0-1023'
                },
                signal: controller.signal
            });

            clearTimeout(timeoutId);
            available = response.ok || response.status === 206;
            console.log(`[Background] Range GET check for ${url}: available=${available}, status=${response.status}`);

            if (available) {
                sendResponse({ success: true, available: true });
                return;
            }
        } catch (rangeError: any) {
            console.log(`[Background] Range GET failed for ${url}:`, rangeError?.message);
        }

        // 鏂规硶3: 瀵逛簬瑙嗛鏂囦欢锛屽皾璇曞垱寤簐ideo鍏冪礌娴嬭瘯
        if (url.includes('.mp4') || url.includes('.webm') || url.includes('.avi')) {
            try {
                // 杩欎釜鏂规硶鍦╞ackground script涓笉鍙敤锛岃烦杩?
                console.log(`[Background] Video URL detected, but cannot test in background: ${url}`);
            } catch (videoError: any) {
                console.log(`[Background] Video test failed for ${url}:`, videoError?.message);
            }
        }

        // 鏂规硶4: 鍩轰簬鍩熷悕鐨勫惎鍙戝紡鍒ゆ柇
        const knownBadDomains = [
            'smovie.caribbeancom.com',
            'smovie.1pondo.tv',
            'smovie.10musume.com',
            'fms.pacopacomama.com'
        ];

        const isKnownBad = knownBadDomains.some(domain => url.includes(domain));

        if (isKnownBad) {
            console.log(`[Background] Known problematic domain for ${url}, marking unavailable`);
            available = false;
        } else {
            console.log(`[Background] Unknown or not explicitly allowed domain for ${url}, defaulting to unavailable`);
            available = false; // 淇濆畧澶勭悊锛岄伩鍏嶈鍒?
        }

        sendResponse({ success: true, available });
    } catch (error: any) {
        console.error(`[Background] Failed to check video URL ${message.url}:`, error);
        sendResponse({ success: false, available: false });
    }
}

// 浠嶫avSpyl鑾峰彇棰勮瑙嗛
async function handleFetchJavSpylPreview(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const { code } = message;
        if (!code) {
            sendResponse({ success: false, error: 'No code provided' });
            return;
        }

        console.log(`[Background] Fetching JavSpyl preview for: ${code}`);

        const response = await fetch('https://v2.javspyl.tk/api/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Origin': 'https://javspyl.tk',
                'Referer': 'https://javspyl.tk/',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            body: JSON.stringify({ ID: code })
        });

        console.log(`[Background] JavSpyl API response status: ${response.status}`);

        if (!response.ok) {
            console.log(`[Background] JavSpyl API request failed: ${response.status} ${response.statusText}`);
            sendResponse({ success: false, error: `API request failed: ${response.status}` });
            return;
        }

        const data = await response.json();
        console.log(`[Background] JavSpyl API response data:`, data);

        const videoUrl = data?.info?.url;

        if (!videoUrl) {
            console.log(`[Background] No video URL found in JavSpyl response for ${code}`);
            sendResponse({ success: false, error: 'No video URL found in response' });
            return;
        }

        if (/\.m3u8?$/i.test(videoUrl)) {
            console.log(`[Background] JavSpyl returned m3u8 URL, skipping: ${videoUrl}`);
            sendResponse({ success: false, error: 'M3U8 format not supported' });
            return;
        }

        const finalUrl = videoUrl.includes('//') ? videoUrl : `https://${videoUrl}`;
        console.log(`[Background] JavSpyl final video URL: ${finalUrl}`);

        // 绠€鍖栭獙璇?- 鐩存帴杩斿洖URL锛岃鍓嶇澶勭悊
        sendResponse({ success: true, videoUrl: finalUrl });
    } catch (error: any) {
        console.error(`[Background] Failed to fetch JavSpyl preview for ${message.code}:`, error);
        sendResponse({ success: false, error: error.message });
    }
}

// 浠嶢VPreview鑾峰彇棰勮瑙嗛
async function handleFetchAVPreviewPreview(message: any, sendResponse: (response: any) => void): Promise<void> {
    try {
        const { code } = message;
        if (!code) {
            sendResponse({ success: false, error: 'No code provided' });
            return;
        }

        // 绗竴姝ワ細鎼滅储瑙嗛
        const searchResponse = await fetch(`https://avpreview.com/zh/search?keywords=${code}`);
        if (!searchResponse.ok) {
            sendResponse({ success: false, error: 'Search request failed' });
            return;
        }

        const searchHtml = await searchResponse.text();
        const parser = new DOMParser();
        const searchDoc = parser.parseFromString(searchHtml, 'text/html');

        // 鏌ユ壘鍖归厤鐨勮棰?
        const videoBoxes = Array.from(searchDoc.querySelectorAll('.container .videobox'));
        const matchedBox = videoBoxes.find(item => {
            const titleElement = item.querySelector('h2 strong');
            return titleElement && titleElement.textContent === code;
        });

        if (!matchedBox) {
            sendResponse({ success: false, error: 'Video not found in search results' });
            return;
        }

        const detailLink = matchedBox.querySelector('a')?.getAttribute('href');
        if (!detailLink) {
            sendResponse({ success: false, error: 'No detail link found' });
            return;
        }

        const contentId = detailLink.split('/').pop();
        if (!contentId) {
            sendResponse({ success: false, error: 'No content ID found' });
            return;
        }

        // 绗簩姝ワ細鑾峰彇瑙嗛璇︽儏
        const apiUrl = new URL('https://avpreview.com/API/v1.0/index.php');
        apiUrl.searchParams.set('system', 'videos');
        apiUrl.searchParams.set('action', 'detail');
        apiUrl.searchParams.set('contentid', contentId);
        apiUrl.searchParams.set('sitecode', 'avpreview');
        apiUrl.searchParams.set('ip', '');
        apiUrl.searchParams.set('token', '');

        const apiResponse = await fetch(apiUrl.toString());
        if (!apiResponse.ok) {
            sendResponse({ success: false, error: 'API detail request failed' });
            return;
        }

        const apiData = await apiResponse.json();
        let trailerUrl = apiData?.videos?.trailer;

        if (!trailerUrl) {
            sendResponse({ success: false, error: 'No trailer URL found' });
            return;
        }

        // 杞崲URL鏍煎紡
        trailerUrl = trailerUrl.replace('/hlsvideo/', '/litevideo/').replace('/playlist.m3u8', '');
        const finalContentId = trailerUrl.split('/').pop();

        // 灏濊瘯涓嶅悓鐨勮棰戞牸寮?
        const videoUrls = [
            `${trailerUrl}/${finalContentId}_dmb_w.mp4`,
            `${trailerUrl}/${finalContentId}_mhb_w.mp4`,
            `${trailerUrl}/${finalContentId}_dm_w.mp4`,
            `${trailerUrl}/${finalContentId}_sm_w.mp4`,
        ];

        // 妫€鏌ュ摢涓猆RL鍙敤
        for (const url of videoUrls) {
            try {
                const checkResponse = await fetch(url, { method: 'HEAD', mode: 'no-cors' });
                const available = checkResponse.ok || checkResponse.type === 'opaque';
                if (available) {
                    sendResponse({ success: true, videoUrl: url });
                    return;
                }
            } catch (err) {
                // ignore and try next
            }
        }

        // 鎵€鏈夊皾璇曢兘澶辫触浜?
        sendResponse({ success: false, error: 'No accessible video URL found' });
        return;
    } catch (error: any) {
        console.error(`[Background] Failed to fetch AVPreview preview for ${message.code}:`, error);
        sendResponse({ success: false, error: error.message });
    }
}

chrome.runtime.onStartup.addListener(async () => {
    setupAlarms();
    triggerAutoSync();

    // 鍒濆鍖栨柊浣滃搧璋冨害鍣?
    try {
        await newWorksScheduler.initialize();
    } catch (error: any) {
        logger.error('鍒濆鍖栨柊浣滃搧璋冨害鍣ㄥけ璐?', error);
    }
});

