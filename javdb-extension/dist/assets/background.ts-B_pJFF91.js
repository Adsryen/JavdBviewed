import{a as p,g as l,b as y,s as m,S as w}from"./storage-BUa3Gg3q.js";const s={info:(...e)=>console.log("[INFO]",...e),warn:(...e)=>console.warn("[WARN]",...e),error:(...e)=>console.error("[ERROR]",...e),debug:(...e)=>console.debug("[DEBUG]",...e)};async function v(){await s.info("Attempting to perform WebDAV upload.");const e=await l();if(!e.webdav.enabled||!e.webdav.url){const t="WebDAV is not enabled or URL is not configured.";return await s.warn(t),{success:!1,error:t}}try{const t=await p(w.VIEWED_RECORDS,{}),a={settings:e,data:t},n=`/javdb-extension-backup-${new Date().toISOString().split("T")[0]}.json`;let o=e.webdav.url;o.endsWith("/")||(o+="/"),o+=n.startsWith("/")?n.substring(1):n,await s.info(`Uploading to ${o}`);const d=await fetch(o,{method:"PUT",headers:{Authorization:"Basic "+btoa(`${e.webdav.username}:${e.webdav.password}`),"Content-Type":"application/json"},body:JSON.stringify(a,null,2)});if(!d.ok)throw new Error(`Upload failed with status: ${d.status}`);return await s.info("WebDAV upload successful."),{success:!0}}catch(t){return await s.error("WebDAV upload failed.",{error:t.message}),{success:!1,error:t.message}}}async function W(e,t={restoreSettings:!0,restoreRecords:!0}){await s.info("Attempting to restore from WebDAV.",{filename:e,options:t});const a=await l();if(!a.webdav.enabled||!a.webdav.url){const r="WebDAV is not enabled or URL is not configured.";return await s.warn(r),{success:!1,error:r}}try{let r;const n=a.webdav.url;if(e.startsWith("http://")||e.startsWith("https://"))r=e;else if(e.startsWith("/")){const i=new URL(n).origin;r=new URL(e,i).href}else{let i=n;i.endsWith("/")||(i+="/"),r=new URL(e,i).href}await s.info(`Attempting to restore from WebDAV URL: ${r}`);const o=await fetch(r,{method:"GET",headers:{Authorization:"Basic "+btoa(`${a.webdav.username}:${a.webdav.password}`)}});if(!o.ok)throw new Error(`Download failed with status: ${o.status}`);const d=await o.text(),c=JSON.parse(d);return c.settings&&t.restoreSettings&&await y(c.settings),c.data&&t.restoreRecords?await m(w.VIEWED_RECORDS,c.data):t.restoreRecords&&await m(w.VIEWED_RECORDS,c),await s.info("Successfully restored from WebDAV.",{filename:e}),{success:!0}}catch(r){return await s.error("Failed to restore from WebDAV.",{error:r.message,filename:e}),{success:!1,error:r.message}}}async function R(){await s.info("Attempting to list files from WebDAV.");const e=await l();if(!e.webdav.enabled||!e.webdav.url){const t="WebDAV is not enabled or URL is not configured.";return await s.warn(t),{success:!1,error:t}}try{let t=e.webdav.url;t.endsWith("/")||(t+="/");const a=await fetch(t,{method:"PROPFIND",headers:{Authorization:"Basic "+btoa(`${e.webdav.username}:${e.webdav.password}`),Depth:"1"}});if(!a.ok)throw new Error(`Failed to list files with status: ${a.status}`);const r=await a.text();await s.debug("Received WebDAV PROPFIND response:",{response:r});const n=S(r);return await s.debug("Parsed WebDAV files:",{files:n}),await s.info(`Successfully listed ${n.length} backup files from WebDAV.`),{success:!0,files:n}}catch(t){return await s.error("Failed to list WebDAV files.",{error:t.message}),{success:!1,error:t.message}}}function S(e){const t=[],a=e.replace(/<(\/)?\w+:/g,"<$1"),r=/<response>(.*?)<\/response>/gs,n=/<href>(.*?)<\/href>/,o=/<getlastmodified>(.*?)<\/getlastmodified>/,d=/<resourcetype>\s*<collection\s*\/>\s*<\/resourcetype>/;let c;for(;(c=r.exec(a))!==null;){const i=c[1],b=i.match(n);if(b){const u=b[1],g=decodeURIComponent(u.split("/").filter(Boolean).pop()||"");if(d.test(i)||u.endsWith("/"))continue;if(g.includes("javdb-extension-backup")){const h=i.match(o),A=h?new Date(h[1]).toLocaleString():"N/A";t.push({name:g,path:u,lastModified:A,isDirectory:!1})}}}return t}async function V(){await s.info("Testing WebDAV connection.");const e=await l();if(!e.webdav.url||!e.webdav.username||!e.webdav.password){const t="WebDAV connection details are not fully configured.";return await s.warn(t),{success:!1,error:t}}try{const t=await fetch(e.webdav.url,{method:"PROPFIND",headers:{Authorization:"Basic "+btoa(`${e.webdav.username}:${e.webdav.password}`),Depth:"0"}});if(t.ok)return await s.info("WebDAV connection test successful."),{success:!0};{const a=`Connection test failed with status: ${t.status}`;return await s.warn(a),{success:!1,error:a}}}catch(t){return await s.error("WebDAV connection test failed.",{error:t.message}),{success:!1,error:t.message}}}chrome.runtime.onMessage.addListener((e,t,a)=>{switch(e.type){case"webdav-upload":return v().then(a),!0;case"webdav-restore":return W(e.filename,e.options).then(a),!0;case"webdav-list-files":return R().then(a),!0;case"webdav-test":return V().then(a),!0;case"setup-alarms":return f(),!1;case"get-logs":return p("extension_logs",[]).then(r=>a({success:!0,logs:r})),!0;default:return!1}});async function D(){await s.info("Checking if auto-sync should be triggered.");const e=await l();if(e.webdav.enabled&&e.webdav.autoSync){await s.info("Performing daily auto-sync...");const t=await v();if(t&&t.success){await s.info("Daily auto-sync successful.");const a=await l();a.webdav.lastSync=new Date().toISOString(),await y(a)}else await s.error("Daily auto-sync failed.",{error:t?t.error:"No response."})}else await s.info("Auto-sync is disabled, skipping.")}async function f(){await s.info("Setting up alarms for auto-sync.");const e=await l(),t=e.webdav.syncInterval||1440,a=await chrome.alarms.get("daily-webdav-sync");a&&a.periodInMinutes!==t&&(await chrome.alarms.clear("daily-webdav-sync"),s.info("Cleared existing alarm due to interval change.")),e.webdav.enabled&&e.webdav.autoSync?(chrome.alarms.create("daily-webdav-sync",{delayInMinutes:1,periodInMinutes:t}),await s.info(`Created/updated auto-sync alarm with interval: ${t} minutes.`)):await chrome.alarms.clear("daily-webdav-sync")&&s.info("Auto-sync is disabled, clearing any existing alarms.")}chrome.runtime.onStartup.addListener(()=>{f(),D()});chrome.runtime.onInstalled.addListener(()=>{f()});chrome.alarms.onAlarm.addListener(async e=>{e.name==="daily-webdav-sync"&&(await s.info(`Alarm '${e.name}' triggered, starting auto-sync.`),await D())});
